// Code generated by protoc-gen-gno. DO NOT EDIT.

package feedsv1

import (
	"errors"
	"strconv"

	"gno.land/p/demo/json"
)

func (p *PostGeoLoc) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.Lat != 0 {
		fields["lat"] = json.NumberNode("", float64(p.Lat))
	}
	if p.Lng != 0 {
		fields["lng"] = json.NumberNode("", float64(p.Lng))
	}

	return json.ObjectNode("", fields)
}

func (p *PostGeoLoc) FromJSON(node *json.Node) {
	*p = PostGeoLoc{}
	fields := node.MustObject()

	if val, ok := fields["lat"]; ok {
		p.Lat = float32(val.MustNumeric())
	}
	if val, ok := fields["lng"]; ok {
		p.Lng = float32(val.MustNumeric())
	}
}

func (s *StandardPost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if s.Content != "" {
		fields["content"] = json.StringNode("", s.Content)
	}

	return json.ObjectNode("", fields)
}

func (s *StandardPost) FromJSON(node *json.Node) {
	*s = StandardPost{}
	fields := node.MustObject()

	if val, ok := fields["content"]; ok {
		s.Content = val.MustString()
	}
}

func (a *ArticlePost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Title != "" {
		fields["title"] = json.StringNode("", a.Title)
	}
	if a.PreviewText != "" {
		fields["previewText"] = json.StringNode("", a.PreviewText)
	}
	if a.PreviewImageUri != "" {
		fields["previewImageUri"] = json.StringNode("", a.PreviewImageUri)
	}
	if a.Content != "" {
		fields["content"] = json.StringNode("", a.Content)
	}

	return json.ObjectNode("", fields)
}

func (a *ArticlePost) FromJSON(node *json.Node) {
	*a = ArticlePost{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		a.Title = val.MustString()
	}
	if val, ok := fields["previewText"]; ok {
		a.PreviewText = val.MustString()
	}
	if val, ok := fields["previewImageUri"]; ok {
		a.PreviewImageUri = val.MustString()
	}
	if val, ok := fields["content"]; ok {
		a.Content = val.MustString()
	}
}

func (l *LinkPost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if l.Uri != "" {
		fields["uri"] = json.StringNode("", l.Uri)
	}

	return json.ObjectNode("", fields)
}

func (l *LinkPost) FromJSON(node *json.Node) {
	*l = LinkPost{}
	fields := node.MustObject()

	if val, ok := fields["uri"]; ok {
		l.Uri = val.MustString()
	}
}

func (i *ImagePost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if i.Title != "" {
		fields["title"] = json.StringNode("", i.Title)
	}
	if i.Description != "" {
		fields["description"] = json.StringNode("", i.Description)
	}
	if i.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", i.ImageUri)
	}

	return json.ObjectNode("", fields)
}

func (i *ImagePost) FromJSON(node *json.Node) {
	*i = ImagePost{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		i.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		i.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		i.ImageUri = val.MustString()
	}
}

func (a *AudioPost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Title != "" {
		fields["title"] = json.StringNode("", a.Title)
	}
	if a.Description != "" {
		fields["description"] = json.StringNode("", a.Description)
	}
	if a.AudioUri != "" {
		fields["audioUri"] = json.StringNode("", a.AudioUri)
	}
	if a.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", a.ImageUri)
	}

	return json.ObjectNode("", fields)
}

func (a *AudioPost) FromJSON(node *json.Node) {
	*a = AudioPost{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		a.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		a.Description = val.MustString()
	}
	if val, ok := fields["audioUri"]; ok {
		a.AudioUri = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		a.ImageUri = val.MustString()
	}
}

func (v *VideoPost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if v.Title != "" {
		fields["title"] = json.StringNode("", v.Title)
	}
	if v.Description != "" {
		fields["description"] = json.StringNode("", v.Description)
	}
	if v.VideoUri != "" {
		fields["videoUri"] = json.StringNode("", v.VideoUri)
	}
	if v.ThumbnailImageUri != "" {
		fields["thumbnailImageUri"] = json.StringNode("", v.ThumbnailImageUri)
	}

	return json.ObjectNode("", fields)
}

func (v *VideoPost) FromJSON(node *json.Node) {
	*v = VideoPost{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		v.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		v.Description = val.MustString()
	}
	if val, ok := fields["videoUri"]; ok {
		v.VideoUri = val.MustString()
	}
	if val, ok := fields["thumbnailImageUri"]; ok {
		v.ThumbnailImageUri = val.MustString()
	}
}

func (r *Reaction) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if r.PostUri != "" {
		fields["postUri"] = json.StringNode("", r.PostUri)
	}
	if r.Icon != "" {
		fields["icon"] = json.StringNode("", r.Icon)
	}
	if r.UserId != "" {
		fields["userId"] = json.StringNode("", r.UserId)
	}

	return json.ObjectNode("", fields)
}

func (r *Reaction) FromJSON(node *json.Node) {
	*r = Reaction{}
	fields := node.MustObject()

	if val, ok := fields["postUri"]; ok {
		r.PostUri = val.MustString()
	}
	if val, ok := fields["icon"]; ok {
		r.Icon = val.MustString()
	}
	if val, ok := fields["userId"]; ok {
		r.UserId = val.MustString()
	}
}

func (t *Tip) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if t.PostLocalId != "" {
		fields["postLocalId"] = json.StringNode("", t.PostLocalId)
	}
	if t.Denom != "" {
		fields["denom"] = json.StringNode("", t.Denom)
	}
	if t.Amount != 0 {
		fields["amount"] = json.StringNode("", strconv.FormatInt(t.Amount, 10))
	}

	return json.ObjectNode("", fields)
}

func (t *Tip) FromJSON(node *json.Node) {
	*t = Tip{}
	fields := node.MustObject()

	if val, ok := fields["postLocalId"]; ok {
		t.PostLocalId = val.MustString()
	}
	if val, ok := fields["denom"]; ok {
		t.Denom = val.MustString()
	}
	if val, ok := fields["amount"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		t.Amount = fv
	}
}

func (p *Post) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.LocalPostId != 0 {
		fields["localPostId"] = json.StringNode("", strconv.FormatUint(p.LocalPostId, 10))
	}
	if p.Author != "" {
		fields["author"] = json.StringNode("", p.Author)
	}
	if p.ParentUri != "" {
		fields["parentUri"] = json.StringNode("", p.ParentUri)
	}
	if p.Loc != nil {
		fields["loc"] = p.Loc.ToJSON()
	}
	if p.CreatedAt != 0 {
		fields["createdAt"] = json.StringNode("", strconv.FormatInt(p.CreatedAt, 10))
	}
	if p.UpdatedAt != 0 {
		fields["updatedAt"] = json.StringNode("", strconv.FormatInt(p.UpdatedAt, 10))
	}
	if p.DeletedAt != 0 {
		fields["deletedAt"] = json.StringNode("", strconv.FormatInt(p.DeletedAt, 10))
	}
	if len(p.Tags) != 0 {
		arr := make([]*json.Node, len(p.Tags))
		for i, val := range p.Tags {
			arr[i] = json.StringNode("", val)
		}
		fields["tags"] = json.ArrayNode("", arr)
	}

	switch val := p.Post.(type) {
	case *StandardPost:
		fields["standard"] = val.ToJSON()
	case *ArticlePost:
		fields["article"] = val.ToJSON()
	case *LinkPost:
		fields["link"] = val.ToJSON()
	case *ImagePost:
		fields["image"] = val.ToJSON()
	case *VideoPost:
		fields["video"] = val.ToJSON()
	case *AudioPost:
		fields["audio"] = val.ToJSON()
	default:
		panic(errors.New("unknown post variant"))
	}

	return json.ObjectNode("", fields)
}

func (p *Post) FromJSON(node *json.Node) {
	*p = Post{}
	fields := node.MustObject()

	if val, ok := fields["localPostId"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		p.LocalPostId = fv
	}
	if val, ok := fields["author"]; ok {
		p.Author = val.MustString()
	}
	if val, ok := fields["parentUri"]; ok {
		p.ParentUri = val.MustString()
	}
	if val, ok := fields["loc"]; ok {
		fv := &PostGeoLoc{}
		fv.FromJSON(val)
		p.Loc = fv
	}
	if val, ok := fields["createdAt"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		p.CreatedAt = fv
	}
	if val, ok := fields["updatedAt"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		p.UpdatedAt = fv
	}
	if val, ok := fields["deletedAt"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		p.DeletedAt = fv
	}
	if val, ok := fields["tags"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		p.Tags = arr
	}

	variantFieldNames := []string{"standard", "article", "link", "image", "video", "audio"}
	var selectedVariant *json.Node
	var selectedVariantName string
	for _, variantName := range variantFieldNames {
		if variant, ok := fields[variantName]; ok {
			selectedVariantName = variantName
			selectedVariant = variant
		}
		break
	}
	switch selectedVariantName {
	case "standard":
		n := &StandardPost{}
		n.FromJSON(selectedVariant)
		p.Post = n
	case "article":
		n := &ArticlePost{}
		n.FromJSON(selectedVariant)
		p.Post = n
	case "link":
		n := &LinkPost{}
		n.FromJSON(selectedVariant)
		p.Post = n
	case "image":
		n := &ImagePost{}
		n.FromJSON(selectedVariant)
		p.Post = n
	case "video":
		n := &VideoPost{}
		n.FromJSON(selectedVariant)
		p.Post = n
	case "audio":
		n := &AudioPost{}
		n.FromJSON(selectedVariant)
		p.Post = n
	default:
		panic(errors.New("post variant not found"))
	}
}

func (p *PostView) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.Post != nil {
		fields["post"] = p.Post.ToJSON()
	}
	if p.ChildrenCount != 0 {
		fields["childrenCount"] = json.StringNode("", strconv.FormatUint(p.ChildrenCount, 10))
	}
	if len(p.Reactions) != 0 {
		arr := make([]*json.Node, len(p.Reactions))
		for i, val := range p.Reactions {
			arr[i] = val.ToJSON()
		}
		fields["reactions"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func (p *PostView) FromJSON(node *json.Node) {
	*p = PostView{}
	fields := node.MustObject()

	if val, ok := fields["post"]; ok {
		fv := &Post{}
		fv.FromJSON(val)
		p.Post = fv
	}
	if val, ok := fields["childrenCount"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		p.ChildrenCount = fv
	}
	if val, ok := fields["reactions"]; ok {
		jarr := val.MustArray()
		arr := make([]*ReactionView, len(jarr))
		for i, val := range jarr {
			fv := &ReactionView{}
			fv.FromJSON(val)
			arr[i] = fv
		}
		p.Reactions = arr
	}
}

func (r *ReactionView) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if r.Icon != "" {
		fields["icon"] = json.StringNode("", r.Icon)
	}
	if r.Count != 0 {
		fields["count"] = json.NumberNode("", float64(r.Count))
	}
	if r.UserHasVoted != false {
		fields["userHasVoted"] = json.BoolNode("", r.UserHasVoted)
	}

	return json.ObjectNode("", fields)
}

func (r *ReactionView) FromJSON(node *json.Node) {
	*r = ReactionView{}
	fields := node.MustObject()

	if val, ok := fields["icon"]; ok {
		r.Icon = val.MustString()
	}
	if val, ok := fields["count"]; ok {
		r.Count = uint32(val.MustNumeric())
	}
	if val, ok := fields["userHasVoted"]; ok {
		r.UserHasVoted = val.MustBool()
	}
}
