// Code generated by protoc-gen-gno. DO NOT EDIT.

package zenaov1

import (
	"errors"
	"strconv"

	"gno.land/p/onbloc/json"
	v11 "gno.land/p/zenao/feeds/v1"
	v1 "gno.land/p/zenao/polls/v1"
)

func (h *HealthRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func HealthRequestFromJSON(h *HealthRequest, node *json.Node) {
	*h = HealthRequest{}
}

func (h *HealthResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if h.Maintenance != false {
		fields["maintenance"] = json.BoolNode("", h.Maintenance)
	}

	return json.ObjectNode("", fields)
}

func HealthResponseFromJSON(h *HealthResponse, node *json.Node) {
	*h = HealthResponse{}
	fields := node.MustObject()

	if val, ok := fields["maintenance"]; ok {
		h.Maintenance = val.MustBool()
	}
}

func (e *EditUserRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.DisplayName != "" {
		fields["displayName"] = json.StringNode("", e.DisplayName)
	}
	if e.Bio != "" {
		fields["bio"] = json.StringNode("", e.Bio)
	}
	if e.AvatarUri != "" {
		fields["avatarUri"] = json.StringNode("", e.AvatarUri)
	}

	return json.ObjectNode("", fields)
}

func EditUserRequestFromJSON(e *EditUserRequest, node *json.Node) {
	*e = EditUserRequest{}
	fields := node.MustObject()

	if val, ok := fields["displayName"]; ok {
		e.DisplayName = val.MustString()
	}
	if val, ok := fields["bio"]; ok {
		e.Bio = val.MustString()
	}
	if val, ok := fields["avatarUri"]; ok {
		e.AvatarUri = val.MustString()
	}
}

func (e *EditUserResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Id != "" {
		fields["id"] = json.StringNode("", e.Id)
	}

	return json.ObjectNode("", fields)
}

func EditUserResponseFromJSON(e *EditUserResponse, node *json.Node) {
	*e = EditUserResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		e.Id = val.MustString()
	}
}

func (g *GetUserInfoRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func GetUserInfoRequestFromJSON(g *GetUserInfoRequest, node *json.Node) {
	*g = GetUserInfoRequest{}
}

func (g *GetUserInfoResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.RealmId != "" {
		fields["realmId"] = json.StringNode("", g.RealmId)
	}
	if g.Plan != "" {
		fields["plan"] = json.StringNode("", g.Plan)
	}

	return json.ObjectNode("", fields)
}

func GetUserInfoResponseFromJSON(g *GetUserInfoResponse, node *json.Node) {
	*g = GetUserInfoResponse{}
	fields := node.MustObject()

	if val, ok := fields["realmId"]; ok {
		g.RealmId = val.MustString()
	}
	if val, ok := fields["plan"]; ok {
		g.Plan = val.MustString()
	}
}

func (p *Profile) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.Address != "" {
		fields["address"] = json.StringNode("", p.Address)
	}
	if p.DisplayName != "" {
		fields["displayName"] = json.StringNode("", p.DisplayName)
	}
	if p.Bio != "" {
		fields["bio"] = json.StringNode("", p.Bio)
	}
	if p.AvatarUri != "" {
		fields["avatarUri"] = json.StringNode("", p.AvatarUri)
	}

	return json.ObjectNode("", fields)
}

func ProfileFromJSON(p *Profile, node *json.Node) {
	*p = Profile{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		p.Address = val.MustString()
	}
	if val, ok := fields["displayName"]; ok {
		p.DisplayName = val.MustString()
	}
	if val, ok := fields["bio"]; ok {
		p.Bio = val.MustString()
	}
	if val, ok := fields["avatarUri"]; ok {
		p.AvatarUri = val.MustString()
	}
}

func (g *GetUsersProfileRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(g.Addresses) != 0 {
		arr := make([]*json.Node, len(g.Addresses))
		for i, val := range g.Addresses {
			arr[i] = json.StringNode("", val)
		}
		fields["addresses"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func GetUsersProfileRequestFromJSON(g *GetUsersProfileRequest, node *json.Node) {
	*g = GetUsersProfileRequest{}
	fields := node.MustObject()

	if val, ok := fields["addresses"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		g.Addresses = arr
	}
}

func (g *GetUsersProfileResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(g.Profiles) != 0 {
		arr := make([]*json.Node, len(g.Profiles))
		for i, val := range g.Profiles {
			arr[i] = val.ToJSON()
		}
		fields["profiles"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func GetUsersProfileResponseFromJSON(g *GetUsersProfileResponse, node *json.Node) {
	*g = GetUsersProfileResponse{}
	fields := node.MustObject()

	if val, ok := fields["profiles"]; ok {
		jarr := val.MustArray()
		arr := make([]*Profile, len(jarr))
		for i, val := range jarr {
			fv := &Profile{}
			ProfileFromJSON(fv, val)
			arr[i] = fv
		}
		g.Profiles = arr
	}
}

func (g *GetEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.EventId != "" {
		fields["eventId"] = json.StringNode("", g.EventId)
	}

	return json.ObjectNode("", fields)
}

func GetEventRequestFromJSON(g *GetEventRequest, node *json.Node) {
	*g = GetEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		g.EventId = val.MustString()
	}
}

func (l *ListEventsRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if l.EntityId != "" {
		fields["entityId"] = json.StringNode("", l.EntityId)
	}
	if l.EntityType != "" {
		fields["entityType"] = json.StringNode("", l.EntityType)
	}
	if l.Role != "" {
		fields["role"] = json.StringNode("", l.Role)
	}
	if l.Limit != 0 {
		fields["limit"] = json.NumberNode("", float64(l.Limit))
	}
	if l.Offset != 0 {
		fields["offset"] = json.NumberNode("", float64(l.Offset))
	}

	return json.ObjectNode("", fields)
}

func ListEventsRequestFromJSON(l *ListEventsRequest, node *json.Node) {
	*l = ListEventsRequest{}
	fields := node.MustObject()

	if val, ok := fields["entityId"]; ok {
		l.EntityId = val.MustString()
	}
	if val, ok := fields["entityType"]; ok {
		l.EntityType = val.MustString()
	}
	if val, ok := fields["role"]; ok {
		l.Role = val.MustString()
	}
	if val, ok := fields["limit"]; ok {
		l.Limit = uint32(val.MustNumeric())
	}
	if val, ok := fields["offset"]; ok {
		l.Offset = uint32(val.MustNumeric())
	}
}

func (l *ListEventsByOrganizerRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if l.OrganizerId != "" {
		fields["organizerId"] = json.StringNode("", l.OrganizerId)
	}
	if l.Limit != 0 {
		fields["limit"] = json.NumberNode("", float64(l.Limit))
	}
	if l.Offset != 0 {
		fields["offset"] = json.NumberNode("", float64(l.Offset))
	}

	return json.ObjectNode("", fields)
}

func ListEventsByOrganizerRequestFromJSON(l *ListEventsByOrganizerRequest, node *json.Node) {
	*l = ListEventsByOrganizerRequest{}
	fields := node.MustObject()

	if val, ok := fields["organizerId"]; ok {
		l.OrganizerId = val.MustString()
	}
	if val, ok := fields["limit"]; ok {
		l.Limit = uint32(val.MustNumeric())
	}
	if val, ok := fields["offset"]; ok {
		l.Offset = uint32(val.MustNumeric())
	}
}

func (l *ListEventsByParticipantRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if l.ParticipantId != "" {
		fields["participantId"] = json.StringNode("", l.ParticipantId)
	}
	if l.Limit != 0 {
		fields["limit"] = json.NumberNode("", float64(l.Limit))
	}
	if l.Offset != 0 {
		fields["offset"] = json.NumberNode("", float64(l.Offset))
	}

	return json.ObjectNode("", fields)
}

func ListEventsByParticipantRequestFromJSON(l *ListEventsByParticipantRequest, node *json.Node) {
	*l = ListEventsByParticipantRequest{}
	fields := node.MustObject()

	if val, ok := fields["participantId"]; ok {
		l.ParticipantId = val.MustString()
	}
	if val, ok := fields["limit"]; ok {
		l.Limit = uint32(val.MustNumeric())
	}
	if val, ok := fields["offset"]; ok {
		l.Offset = uint32(val.MustNumeric())
	}
}

func (c *CreateEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.Title != "" {
		fields["title"] = json.StringNode("", c.Title)
	}
	if c.Description != "" {
		fields["description"] = json.StringNode("", c.Description)
	}
	if c.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", c.ImageUri)
	}
	if c.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatUint(c.StartDate, 10))
	}
	if c.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatUint(c.EndDate, 10))
	}
	if c.TicketPrice != 0 {
		fields["ticketPrice"] = json.NumberNode("", float64(c.TicketPrice))
	}
	if c.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(c.Capacity))
	}
	if c.Location != nil {
		fields["location"] = c.Location.ToJSON()
	}
	if c.Password != "" {
		fields["password"] = json.StringNode("", c.Password)
	}
	if len(c.Organizers) != 0 {
		arr := make([]*json.Node, len(c.Organizers))
		for i, val := range c.Organizers {
			arr[i] = json.StringNode("", val)
		}
		fields["organizers"] = json.ArrayNode("", arr)
	}
	if len(c.Gatekeepers) != 0 {
		arr := make([]*json.Node, len(c.Gatekeepers))
		for i, val := range c.Gatekeepers {
			arr[i] = json.StringNode("", val)
		}
		fields["gatekeepers"] = json.ArrayNode("", arr)
	}
	if c.Discoverable != false {
		fields["discoverable"] = json.BoolNode("", c.Discoverable)
	}
	if c.CommunityId != "" {
		fields["communityId"] = json.StringNode("", c.CommunityId)
	}
	if c.CommunityEmail != false {
		fields["communityEmail"] = json.BoolNode("", c.CommunityEmail)
	}

	return json.ObjectNode("", fields)
}

func CreateEventRequestFromJSON(c *CreateEventRequest, node *json.Node) {
	*c = CreateEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		c.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		c.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		c.ImageUri = val.MustString()
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		c.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		c.EndDate = fv
	}
	if val, ok := fields["ticketPrice"]; ok {
		c.TicketPrice = val.MustNumeric()
	}
	if val, ok := fields["capacity"]; ok {
		c.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		EventLocationFromJSON(fv, val)
		c.Location = fv
	}
	if val, ok := fields["password"]; ok {
		c.Password = val.MustString()
	}
	if val, ok := fields["organizers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		c.Organizers = arr
	}
	if val, ok := fields["gatekeepers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		c.Gatekeepers = arr
	}
	if val, ok := fields["discoverable"]; ok {
		c.Discoverable = val.MustBool()
	}
	if val, ok := fields["communityId"]; ok {
		c.CommunityId = val.MustString()
	}
	if val, ok := fields["communityEmail"]; ok {
		c.CommunityEmail = val.MustBool()
	}
}

func (c *CreateEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.Id != "" {
		fields["id"] = json.StringNode("", c.Id)
	}

	return json.ObjectNode("", fields)
}

func CreateEventResponseFromJSON(c *CreateEventResponse, node *json.Node) {
	*c = CreateEventResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		c.Id = val.MustString()
	}
}

func (c *CancelEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.EventId != "" {
		fields["eventId"] = json.StringNode("", c.EventId)
	}

	return json.ObjectNode("", fields)
}

func CancelEventRequestFromJSON(c *CancelEventRequest, node *json.Node) {
	*c = CancelEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		c.EventId = val.MustString()
	}
}

func (c *CancelEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func CancelEventResponseFromJSON(c *CancelEventResponse, node *json.Node) {
	*c = CancelEventResponse{}
}

func (e *EditEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.EventId != "" {
		fields["eventId"] = json.StringNode("", e.EventId)
	}
	if e.Title != "" {
		fields["title"] = json.StringNode("", e.Title)
	}
	if e.Description != "" {
		fields["description"] = json.StringNode("", e.Description)
	}
	if e.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", e.ImageUri)
	}
	if e.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatUint(e.StartDate, 10))
	}
	if e.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatUint(e.EndDate, 10))
	}
	if e.TicketPrice != 0 {
		fields["ticketPrice"] = json.NumberNode("", float64(e.TicketPrice))
	}
	if e.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(e.Capacity))
	}
	if e.Location != nil {
		fields["location"] = e.Location.ToJSON()
	}
	if e.Password != "" {
		fields["password"] = json.StringNode("", e.Password)
	}
	if e.UpdatePassword != false {
		fields["updatePassword"] = json.BoolNode("", e.UpdatePassword)
	}
	if len(e.Organizers) != 0 {
		arr := make([]*json.Node, len(e.Organizers))
		for i, val := range e.Organizers {
			arr[i] = json.StringNode("", val)
		}
		fields["organizers"] = json.ArrayNode("", arr)
	}
	if len(e.Gatekeepers) != 0 {
		arr := make([]*json.Node, len(e.Gatekeepers))
		for i, val := range e.Gatekeepers {
			arr[i] = json.StringNode("", val)
		}
		fields["gatekeepers"] = json.ArrayNode("", arr)
	}
	if e.Discoverable != false {
		fields["discoverable"] = json.BoolNode("", e.Discoverable)
	}
	if e.CommunityId != "" {
		fields["communityId"] = json.StringNode("", e.CommunityId)
	}
	if e.CommunityEmail != false {
		fields["communityEmail"] = json.BoolNode("", e.CommunityEmail)
	}

	return json.ObjectNode("", fields)
}

func EditEventRequestFromJSON(e *EditEventRequest, node *json.Node) {
	*e = EditEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		e.EventId = val.MustString()
	}
	if val, ok := fields["title"]; ok {
		e.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		e.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		e.ImageUri = val.MustString()
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.EndDate = fv
	}
	if val, ok := fields["ticketPrice"]; ok {
		e.TicketPrice = val.MustNumeric()
	}
	if val, ok := fields["capacity"]; ok {
		e.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		EventLocationFromJSON(fv, val)
		e.Location = fv
	}
	if val, ok := fields["password"]; ok {
		e.Password = val.MustString()
	}
	if val, ok := fields["updatePassword"]; ok {
		e.UpdatePassword = val.MustBool()
	}
	if val, ok := fields["organizers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Organizers = arr
	}
	if val, ok := fields["gatekeepers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Gatekeepers = arr
	}
	if val, ok := fields["discoverable"]; ok {
		e.Discoverable = val.MustBool()
	}
	if val, ok := fields["communityId"]; ok {
		e.CommunityId = val.MustString()
	}
	if val, ok := fields["communityEmail"]; ok {
		e.CommunityEmail = val.MustBool()
	}
}

func (e *EditEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Id != "" {
		fields["id"] = json.StringNode("", e.Id)
	}

	return json.ObjectNode("", fields)
}

func EditEventResponseFromJSON(e *EditEventResponse, node *json.Node) {
	*e = EditEventResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		e.Id = val.MustString()
	}
}

func (g *GetEventGatekeepersRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.EventId != "" {
		fields["eventId"] = json.StringNode("", g.EventId)
	}

	return json.ObjectNode("", fields)
}

func GetEventGatekeepersRequestFromJSON(g *GetEventGatekeepersRequest, node *json.Node) {
	*g = GetEventGatekeepersRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		g.EventId = val.MustString()
	}
}

func (g *GetEventGatekeepersResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(g.Gatekeepers) != 0 {
		arr := make([]*json.Node, len(g.Gatekeepers))
		for i, val := range g.Gatekeepers {
			arr[i] = json.StringNode("", val)
		}
		fields["gatekeepers"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func GetEventGatekeepersResponseFromJSON(g *GetEventGatekeepersResponse, node *json.Node) {
	*g = GetEventGatekeepersResponse{}
	fields := node.MustObject()

	if val, ok := fields["gatekeepers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		g.Gatekeepers = arr
	}
}

func (v *ValidatePasswordRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if v.EventId != "" {
		fields["eventId"] = json.StringNode("", v.EventId)
	}
	if v.Password != "" {
		fields["password"] = json.StringNode("", v.Password)
	}

	return json.ObjectNode("", fields)
}

func ValidatePasswordRequestFromJSON(v *ValidatePasswordRequest, node *json.Node) {
	*v = ValidatePasswordRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		v.EventId = val.MustString()
	}
	if val, ok := fields["password"]; ok {
		v.Password = val.MustString()
	}
}

func (v *ValidatePasswordResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if v.Valid != false {
		fields["valid"] = json.BoolNode("", v.Valid)
	}

	return json.ObjectNode("", fields)
}

func ValidatePasswordResponseFromJSON(v *ValidatePasswordResponse, node *json.Node) {
	*v = ValidatePasswordResponse{}
	fields := node.MustObject()

	if val, ok := fields["valid"]; ok {
		v.Valid = val.MustBool()
	}
}

func (p *ParticipateRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.EventId != "" {
		fields["eventId"] = json.StringNode("", p.EventId)
	}
	if p.Email != "" {
		fields["email"] = json.StringNode("", p.Email)
	}
	if len(p.Guests) != 0 {
		arr := make([]*json.Node, len(p.Guests))
		for i, val := range p.Guests {
			arr[i] = json.StringNode("", val)
		}
		fields["guests"] = json.ArrayNode("", arr)
	}
	if p.Password != "" {
		fields["password"] = json.StringNode("", p.Password)
	}

	return json.ObjectNode("", fields)
}

func ParticipateRequestFromJSON(p *ParticipateRequest, node *json.Node) {
	*p = ParticipateRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		p.EventId = val.MustString()
	}
	if val, ok := fields["email"]; ok {
		p.Email = val.MustString()
	}
	if val, ok := fields["guests"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		p.Guests = arr
	}
	if val, ok := fields["password"]; ok {
		p.Password = val.MustString()
	}
}

func (c *CancelParticipationRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.EventId != "" {
		fields["eventId"] = json.StringNode("", c.EventId)
	}

	return json.ObjectNode("", fields)
}

func CancelParticipationRequestFromJSON(c *CancelParticipationRequest, node *json.Node) {
	*c = CancelParticipationRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		c.EventId = val.MustString()
	}
}

func (c *CancelParticipationResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func CancelParticipationResponseFromJSON(c *CancelParticipationResponse, node *json.Node) {
	*c = CancelParticipationResponse{}
}

func (p *ParticipateResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.TicketSecret != "" {
		fields["ticketSecret"] = json.StringNode("", p.TicketSecret)
	}

	return json.ObjectNode("", fields)
}

func ParticipateResponseFromJSON(p *ParticipateResponse, node *json.Node) {
	*p = ParticipateResponse{}
	fields := node.MustObject()

	if val, ok := fields["ticketSecret"]; ok {
		p.TicketSecret = val.MustString()
	}
}

func (b *BroadcastEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if b.EventId != "" {
		fields["eventId"] = json.StringNode("", b.EventId)
	}
	if b.Message != "" {
		fields["message"] = json.StringNode("", b.Message)
	}
	if b.AttachTicket != false {
		fields["attachTicket"] = json.BoolNode("", b.AttachTicket)
	}

	return json.ObjectNode("", fields)
}

func BroadcastEventRequestFromJSON(b *BroadcastEventRequest, node *json.Node) {
	*b = BroadcastEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		b.EventId = val.MustString()
	}
	if val, ok := fields["message"]; ok {
		b.Message = val.MustString()
	}
	if val, ok := fields["attachTicket"]; ok {
		b.AttachTicket = val.MustBool()
	}
}

func (b *BroadcastEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func BroadcastEventResponseFromJSON(b *BroadcastEventResponse, node *json.Node) {
	*b = BroadcastEventResponse{}
}

func (e *EventLocation) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.VenueName != "" {
		fields["venueName"] = json.StringNode("", e.VenueName)
	}
	if e.Instructions != "" {
		fields["instructions"] = json.StringNode("", e.Instructions)
	}

	switch val := e.Address.(type) {
	case *AddressGeo:
		fields["geo"] = val.ToJSON()
	case *AddressVirtual:
		fields["virtual"] = val.ToJSON()
	case *AddressCustom:
		fields["custom"] = val.ToJSON()
	default:
		panic(errors.New("unknown address variant"))
	}

	return json.ObjectNode("", fields)
}

func EventLocationFromJSON(e *EventLocation, node *json.Node) {
	*e = EventLocation{}
	fields := node.MustObject()

	if val, ok := fields["venueName"]; ok {
		e.VenueName = val.MustString()
	}
	if val, ok := fields["instructions"]; ok {
		e.Instructions = val.MustString()
	}

	variantFieldNames := []string{"geo", "virtual", "custom"}
	var selectedVariant *json.Node
	var selectedVariantName string
	for _, variantName := range variantFieldNames {
		if variant, ok := fields[variantName]; ok {
			selectedVariantName = variantName
			selectedVariant = variant
		}
		break
	}
	switch selectedVariantName {
	case "geo":
		n := &AddressGeo{}
		AddressGeoFromJSON(n, selectedVariant)
		e.Address = n
	case "virtual":
		n := &AddressVirtual{}
		AddressVirtualFromJSON(n, selectedVariant)
		e.Address = n
	case "custom":
		n := &AddressCustom{}
		AddressCustomFromJSON(n, selectedVariant)
		e.Address = n
	default:
		panic(errors.New("address variant not found"))
	}
}

func (a *AddressVirtual) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Uri != "" {
		fields["uri"] = json.StringNode("", a.Uri)
	}

	return json.ObjectNode("", fields)
}

func AddressVirtualFromJSON(a *AddressVirtual, node *json.Node) {
	*a = AddressVirtual{}
	fields := node.MustObject()

	if val, ok := fields["uri"]; ok {
		a.Uri = val.MustString()
	}
}

func (a *AddressGeo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Address != "" {
		fields["address"] = json.StringNode("", a.Address)
	}
	if a.Lat != 0 {
		fields["lat"] = json.NumberNode("", float64(a.Lat))
	}
	if a.Lng != 0 {
		fields["lng"] = json.NumberNode("", float64(a.Lng))
	}
	if a.Size != 0 {
		fields["size"] = json.NumberNode("", float64(a.Size))
	}

	return json.ObjectNode("", fields)
}

func AddressGeoFromJSON(a *AddressGeo, node *json.Node) {
	*a = AddressGeo{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		a.Address = val.MustString()
	}
	if val, ok := fields["lat"]; ok {
		a.Lat = float32(val.MustNumeric())
	}
	if val, ok := fields["lng"]; ok {
		a.Lng = float32(val.MustNumeric())
	}
	if val, ok := fields["size"]; ok {
		a.Size = float32(val.MustNumeric())
	}
}

func (a *AddressCustom) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Address != "" {
		fields["address"] = json.StringNode("", a.Address)
	}
	if a.Timezone != "" {
		fields["timezone"] = json.StringNode("", a.Timezone)
	}

	return json.ObjectNode("", fields)
}

func AddressCustomFromJSON(a *AddressCustom, node *json.Node) {
	*a = AddressCustom{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		a.Address = val.MustString()
	}
	if val, ok := fields["timezone"]; ok {
		a.Timezone = val.MustString()
	}
}

func (e *EventPrivacy) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	switch val := e.EventPrivacy.(type) {
	case *EventPrivacyPublic:
		fields["public"] = val.ToJSON()
	case *EventPrivacyGuarded:
		fields["guarded"] = val.ToJSON()
	default:
		panic(errors.New("unknown eventPrivacy variant"))
	}

	return json.ObjectNode("", fields)
}

func EventPrivacyFromJSON(e *EventPrivacy, node *json.Node) {
	*e = EventPrivacy{}
	fields := node.MustObject()

	variantFieldNames := []string{"public", "guarded"}
	var selectedVariant *json.Node
	var selectedVariantName string
	for _, variantName := range variantFieldNames {
		if variant, ok := fields[variantName]; ok {
			selectedVariantName = variantName
			selectedVariant = variant
		}
		break
	}
	switch selectedVariantName {
	case "public":
		n := &EventPrivacyPublic{}
		EventPrivacyPublicFromJSON(n, selectedVariant)
		e.EventPrivacy = n
	case "guarded":
		n := &EventPrivacyGuarded{}
		EventPrivacyGuardedFromJSON(n, selectedVariant)
		e.EventPrivacy = n
	default:
		panic(errors.New("eventPrivacy variant not found"))
	}
}

func (e *EventPrivacyPublic) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func EventPrivacyPublicFromJSON(e *EventPrivacyPublic, node *json.Node) {
	*e = EventPrivacyPublic{}
}

func (e *EventPrivacyGuarded) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.ParticipationPubkey != "" {
		fields["participationPubkey"] = json.StringNode("", e.ParticipationPubkey)
	}

	return json.ObjectNode("", fields)
}

func EventPrivacyGuardedFromJSON(e *EventPrivacyGuarded, node *json.Node) {
	*e = EventPrivacyGuarded{}
	fields := node.MustObject()

	if val, ok := fields["participationPubkey"]; ok {
		e.ParticipationPubkey = val.MustString()
	}
}

func (e *EventInfo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Title != "" {
		fields["title"] = json.StringNode("", e.Title)
	}
	if e.Description != "" {
		fields["description"] = json.StringNode("", e.Description)
	}
	if e.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", e.ImageUri)
	}
	if len(e.Organizers) != 0 {
		arr := make([]*json.Node, len(e.Organizers))
		for i, val := range e.Organizers {
			arr[i] = json.StringNode("", val)
		}
		fields["organizers"] = json.ArrayNode("", arr)
	}
	if len(e.Gatekeepers) != 0 {
		arr := make([]*json.Node, len(e.Gatekeepers))
		for i, val := range e.Gatekeepers {
			arr[i] = json.StringNode("", val)
		}
		fields["gatekeepers"] = json.ArrayNode("", arr)
	}
	if e.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatInt(e.StartDate, 10))
	}
	if e.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatInt(e.EndDate, 10))
	}
	if e.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(e.Capacity))
	}
	if e.Location != nil {
		fields["location"] = e.Location.ToJSON()
	}
	if e.Participants != 0 {
		fields["participants"] = json.NumberNode("", float64(e.Participants))
	}
	if e.PkgPath != "" {
		fields["pkgPath"] = json.StringNode("", e.PkgPath)
	}
	if e.Privacy != nil {
		fields["privacy"] = e.Privacy.ToJSON()
	}
	if e.CheckedIn != 0 {
		fields["checkedIn"] = json.NumberNode("", float64(e.CheckedIn))
	}
	if e.Discoverable != false {
		fields["discoverable"] = json.BoolNode("", e.Discoverable)
	}

	return json.ObjectNode("", fields)
}

func EventInfoFromJSON(e *EventInfo, node *json.Node) {
	*e = EventInfo{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		e.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		e.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		e.ImageUri = val.MustString()
	}
	if val, ok := fields["organizers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Organizers = arr
	}
	if val, ok := fields["gatekeepers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Gatekeepers = arr
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.EndDate = fv
	}
	if val, ok := fields["capacity"]; ok {
		e.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		EventLocationFromJSON(fv, val)
		e.Location = fv
	}
	if val, ok := fields["participants"]; ok {
		e.Participants = uint32(val.MustNumeric())
	}
	if val, ok := fields["pkgPath"]; ok {
		e.PkgPath = val.MustString()
	}
	if val, ok := fields["privacy"]; ok {
		fv := &EventPrivacy{}
		EventPrivacyFromJSON(fv, val)
		e.Privacy = fv
	}
	if val, ok := fields["checkedIn"]; ok {
		e.CheckedIn = uint32(val.MustNumeric())
	}
	if val, ok := fields["discoverable"]; ok {
		e.Discoverable = val.MustBool()
	}
}

func (e *EventsInfo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(e.Events) != 0 {
		arr := make([]*json.Node, len(e.Events))
		for i, val := range e.Events {
			arr[i] = val.ToJSON()
		}
		fields["events"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func EventsInfoFromJSON(e *EventsInfo, node *json.Node) {
	*e = EventsInfo{}
	fields := node.MustObject()

	if val, ok := fields["events"]; ok {
		jarr := val.MustArray()
		arr := make([]*EventInfo, len(jarr))
		for i, val := range jarr {
			fv := &EventInfo{}
			EventInfoFromJSON(fv, val)
			arr[i] = fv
		}
		e.Events = arr
	}
}

func (b *BatchProfileField) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if b.Type != "" {
		fields["type"] = json.StringNode("", b.Type)
	}
	if b.Key != "" {
		fields["key"] = json.StringNode("", b.Key)
	}

	return json.ObjectNode("", fields)
}

func BatchProfileFieldFromJSON(b *BatchProfileField, node *json.Node) {
	*b = BatchProfileField{}
	fields := node.MustObject()

	if val, ok := fields["type"]; ok {
		b.Type = val.MustString()
	}
	if val, ok := fields["key"]; ok {
		b.Key = val.MustString()
	}
}

func (b *BatchProfileRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(b.Fields) != 0 {
		arr := make([]*json.Node, len(b.Fields))
		for i, val := range b.Fields {
			arr[i] = val.ToJSON()
		}
		fields["fields"] = json.ArrayNode("", arr)
	}
	if len(b.Addresses) != 0 {
		arr := make([]*json.Node, len(b.Addresses))
		for i, val := range b.Addresses {
			arr[i] = json.StringNode("", val)
		}
		fields["addresses"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func BatchProfileRequestFromJSON(b *BatchProfileRequest, node *json.Node) {
	*b = BatchProfileRequest{}
	fields := node.MustObject()

	if val, ok := fields["fields"]; ok {
		jarr := val.MustArray()
		arr := make([]*BatchProfileField, len(jarr))
		for i, val := range jarr {
			fv := &BatchProfileField{}
			BatchProfileFieldFromJSON(fv, val)
			arr[i] = fv
		}
		b.Fields = arr
	}
	if val, ok := fields["addresses"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		b.Addresses = arr
	}
}

func (c *CreatePollRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.OrgType != "" {
		fields["orgType"] = json.StringNode("", c.OrgType)
	}
	if c.OrgId != "" {
		fields["orgId"] = json.StringNode("", c.OrgId)
	}
	if c.Question != "" {
		fields["question"] = json.StringNode("", c.Question)
	}
	if len(c.Options) != 0 {
		arr := make([]*json.Node, len(c.Options))
		for i, val := range c.Options {
			arr[i] = json.StringNode("", val)
		}
		fields["options"] = json.ArrayNode("", arr)
	}
	if c.Duration != 0 {
		fields["duration"] = json.StringNode("", strconv.FormatInt(c.Duration, 10))
	}
	if c.Kind != 0 {
		fields["kind"] = json.StringNode("", c.Kind.ToString())
	}

	return json.ObjectNode("", fields)
}

func CreatePollRequestFromJSON(c *CreatePollRequest, node *json.Node) {
	*c = CreatePollRequest{}
	fields := node.MustObject()

	if val, ok := fields["orgType"]; ok {
		c.OrgType = val.MustString()
	}
	if val, ok := fields["orgId"]; ok {
		c.OrgId = val.MustString()
	}
	if val, ok := fields["question"]; ok {
		c.Question = val.MustString()
	}
	if val, ok := fields["options"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		c.Options = arr
	}
	if val, ok := fields["duration"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		c.Duration = fv
	}
	if val, ok := fields["kind"]; ok {
		c.Kind = v1.PollKindFromString(val.MustString())
	}
}

func (c *CreatePollResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.PostId != "" {
		fields["postId"] = json.StringNode("", c.PostId)
	}

	return json.ObjectNode("", fields)
}

func CreatePollResponseFromJSON(c *CreatePollResponse, node *json.Node) {
	*c = CreatePollResponse{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		c.PostId = val.MustString()
	}
}

func (g *GetPollRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.PollId != "" {
		fields["pollId"] = json.StringNode("", g.PollId)
	}
	if g.UserId != "" {
		fields["userId"] = json.StringNode("", g.UserId)
	}

	return json.ObjectNode("", fields)
}

func GetPollRequestFromJSON(g *GetPollRequest, node *json.Node) {
	*g = GetPollRequest{}
	fields := node.MustObject()

	if val, ok := fields["pollId"]; ok {
		g.PollId = val.MustString()
	}
	if val, ok := fields["userId"]; ok {
		g.UserId = val.MustString()
	}
}

func (v *VotePollRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if v.PollId != "" {
		fields["pollId"] = json.StringNode("", v.PollId)
	}
	if v.Option != "" {
		fields["option"] = json.StringNode("", v.Option)
	}

	return json.ObjectNode("", fields)
}

func VotePollRequestFromJSON(v *VotePollRequest, node *json.Node) {
	*v = VotePollRequest{}
	fields := node.MustObject()

	if val, ok := fields["pollId"]; ok {
		v.PollId = val.MustString()
	}
	if val, ok := fields["option"]; ok {
		v.Option = val.MustString()
	}
}

func (v *VotePollResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func VotePollResponseFromJSON(v *VotePollResponse, node *json.Node) {
	*v = VotePollResponse{}
}

func (c *CreatePostRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.OrgType != "" {
		fields["orgType"] = json.StringNode("", c.OrgType)
	}
	if c.OrgId != "" {
		fields["orgId"] = json.StringNode("", c.OrgId)
	}
	if c.Content != "" {
		fields["content"] = json.StringNode("", c.Content)
	}
	if c.ParentId != "" {
		fields["parentId"] = json.StringNode("", c.ParentId)
	}
	if len(c.Tags) != 0 {
		arr := make([]*json.Node, len(c.Tags))
		for i, val := range c.Tags {
			arr[i] = json.StringNode("", val)
		}
		fields["tags"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func CreatePostRequestFromJSON(c *CreatePostRequest, node *json.Node) {
	*c = CreatePostRequest{}
	fields := node.MustObject()

	if val, ok := fields["orgType"]; ok {
		c.OrgType = val.MustString()
	}
	if val, ok := fields["orgId"]; ok {
		c.OrgId = val.MustString()
	}
	if val, ok := fields["content"]; ok {
		c.Content = val.MustString()
	}
	if val, ok := fields["parentId"]; ok {
		c.ParentId = val.MustString()
	}
	if val, ok := fields["tags"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		c.Tags = arr
	}
}

func (c *CreatePostResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.PostId != "" {
		fields["postId"] = json.StringNode("", c.PostId)
	}

	return json.ObjectNode("", fields)
}

func CreatePostResponseFromJSON(c *CreatePostResponse, node *json.Node) {
	*c = CreatePostResponse{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		c.PostId = val.MustString()
	}
}

func (g *GetPostRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.PostId != "" {
		fields["postId"] = json.StringNode("", g.PostId)
	}
	if g.UserId != "" {
		fields["userId"] = json.StringNode("", g.UserId)
	}

	return json.ObjectNode("", fields)
}

func GetPostRequestFromJSON(g *GetPostRequest, node *json.Node) {
	*g = GetPostRequest{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		g.PostId = val.MustString()
	}
	if val, ok := fields["userId"]; ok {
		g.UserId = val.MustString()
	}
}

func (g *GetPostsRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.FeedId != "" {
		fields["feedId"] = json.StringNode("", g.FeedId)
	}
	if g.Limit != 0 {
		fields["limit"] = json.NumberNode("", float64(g.Limit))
	}
	if g.Offset != 0 {
		fields["offset"] = json.NumberNode("", float64(g.Offset))
	}
	if len(g.Tags) != 0 {
		arr := make([]*json.Node, len(g.Tags))
		for i, val := range g.Tags {
			arr[i] = json.StringNode("", val)
		}
		fields["tags"] = json.ArrayNode("", arr)
	}
	if g.ParentId != "" {
		fields["parentId"] = json.StringNode("", g.ParentId)
	}
	if g.UserId != "" {
		fields["userId"] = json.StringNode("", g.UserId)
	}

	return json.ObjectNode("", fields)
}

func GetPostsRequestFromJSON(g *GetPostsRequest, node *json.Node) {
	*g = GetPostsRequest{}
	fields := node.MustObject()

	if val, ok := fields["feedId"]; ok {
		g.FeedId = val.MustString()
	}
	if val, ok := fields["limit"]; ok {
		g.Limit = uint32(val.MustNumeric())
	}
	if val, ok := fields["offset"]; ok {
		g.Offset = uint32(val.MustNumeric())
	}
	if val, ok := fields["tags"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		g.Tags = arr
	}
	if val, ok := fields["parentId"]; ok {
		g.ParentId = val.MustString()
	}
	if val, ok := fields["userId"]; ok {
		g.UserId = val.MustString()
	}
}

func (g *GetPostsResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(g.Posts) != 0 {
		arr := make([]*json.Node, len(g.Posts))
		for i, val := range g.Posts {
			arr[i] = val.ToJSON()
		}
		fields["posts"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func GetPostsResponseFromJSON(g *GetPostsResponse, node *json.Node) {
	*g = GetPostsResponse{}
	fields := node.MustObject()

	if val, ok := fields["posts"]; ok {
		jarr := val.MustArray()
		arr := make([]*v11.PostView, len(jarr))
		for i, val := range jarr {
			fv := &v11.PostView{}
			PostViewFromJSON(fv, val)
			arr[i] = fv
		}
		g.Posts = arr
	}
}

func (d *DeletePostRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if d.PostId != "" {
		fields["postId"] = json.StringNode("", d.PostId)
	}

	return json.ObjectNode("", fields)
}

func DeletePostRequestFromJSON(d *DeletePostRequest, node *json.Node) {
	*d = DeletePostRequest{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		d.PostId = val.MustString()
	}
}

func (d *DeletePostResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func DeletePostResponseFromJSON(d *DeletePostResponse, node *json.Node) {
	*d = DeletePostResponse{}
}

func (r *ReactPostRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if r.PostId != "" {
		fields["postId"] = json.StringNode("", r.PostId)
	}
	if r.Icon != "" {
		fields["icon"] = json.StringNode("", r.Icon)
	}

	return json.ObjectNode("", fields)
}

func ReactPostRequestFromJSON(r *ReactPostRequest, node *json.Node) {
	*r = ReactPostRequest{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		r.PostId = val.MustString()
	}
	if val, ok := fields["icon"]; ok {
		r.Icon = val.MustString()
	}
}

func (r *ReactPostResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func ReactPostResponseFromJSON(r *ReactPostResponse, node *json.Node) {
	*r = ReactPostResponse{}
}

func (e *EditPostRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.PostId != "" {
		fields["postId"] = json.StringNode("", e.PostId)
	}
	if e.Content != "" {
		fields["content"] = json.StringNode("", e.Content)
	}
	if len(e.Tags) != 0 {
		arr := make([]*json.Node, len(e.Tags))
		for i, val := range e.Tags {
			arr[i] = json.StringNode("", val)
		}
		fields["tags"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func EditPostRequestFromJSON(e *EditPostRequest, node *json.Node) {
	*e = EditPostRequest{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		e.PostId = val.MustString()
	}
	if val, ok := fields["content"]; ok {
		e.Content = val.MustString()
	}
	if val, ok := fields["tags"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Tags = arr
	}
}

func (e *EditPostResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.PostId != "" {
		fields["postId"] = json.StringNode("", e.PostId)
	}

	return json.ObjectNode("", fields)
}

func EditPostResponseFromJSON(e *EditPostResponse, node *json.Node) {
	*e = EditPostResponse{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		e.PostId = val.MustString()
	}
}

func (g *GetEventTicketsRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.EventId != "" {
		fields["eventId"] = json.StringNode("", g.EventId)
	}

	return json.ObjectNode("", fields)
}

func GetEventTicketsRequestFromJSON(g *GetEventTicketsRequest, node *json.Node) {
	*g = GetEventTicketsRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		g.EventId = val.MustString()
	}
}

func (g *GetEventTicketsResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(g.TicketsInfo) != 0 {
		arr := make([]*json.Node, len(g.TicketsInfo))
		for i, val := range g.TicketsInfo {
			arr[i] = val.ToJSON()
		}
		fields["ticketsInfo"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func GetEventTicketsResponseFromJSON(g *GetEventTicketsResponse, node *json.Node) {
	*g = GetEventTicketsResponse{}
	fields := node.MustObject()

	if val, ok := fields["ticketsInfo"]; ok {
		jarr := val.MustArray()
		arr := make([]*TicketInfo, len(jarr))
		for i, val := range jarr {
			fv := &TicketInfo{}
			TicketInfoFromJSON(fv, val)
			arr[i] = fv
		}
		g.TicketsInfo = arr
	}
}

func (t *TicketInfo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if t.TicketSecret != "" {
		fields["ticketSecret"] = json.StringNode("", t.TicketSecret)
	}
	if t.UserEmail != "" {
		fields["userEmail"] = json.StringNode("", t.UserEmail)
	}

	return json.ObjectNode("", fields)
}

func TicketInfoFromJSON(t *TicketInfo, node *json.Node) {
	*t = TicketInfo{}
	fields := node.MustObject()

	if val, ok := fields["ticketSecret"]; ok {
		t.TicketSecret = val.MustString()
	}
	if val, ok := fields["userEmail"]; ok {
		t.UserEmail = val.MustString()
	}
}

func (c *CheckinRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.TicketPubkey != "" {
		fields["ticketPubkey"] = json.StringNode("", c.TicketPubkey)
	}
	if c.Signature != "" {
		fields["signature"] = json.StringNode("", c.Signature)
	}

	return json.ObjectNode("", fields)
}

func CheckinRequestFromJSON(c *CheckinRequest, node *json.Node) {
	*c = CheckinRequest{}
	fields := node.MustObject()

	if val, ok := fields["ticketPubkey"]; ok {
		c.TicketPubkey = val.MustString()
	}
	if val, ok := fields["signature"]; ok {
		c.Signature = val.MustString()
	}
}

func (c *CheckinResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func CheckinResponseFromJSON(c *CheckinResponse, node *json.Node) {
	*c = CheckinResponse{}
}

func (e *ExportParticipantsRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.EventId != "" {
		fields["eventId"] = json.StringNode("", e.EventId)
	}

	return json.ObjectNode("", fields)
}

func ExportParticipantsRequestFromJSON(e *ExportParticipantsRequest, node *json.Node) {
	*e = ExportParticipantsRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		e.EventId = val.MustString()
	}
}

func (e *ExportParticipantsResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Content != "" {
		fields["content"] = json.StringNode("", e.Content)
	}
	if e.Filename != "" {
		fields["filename"] = json.StringNode("", e.Filename)
	}
	if e.MimeType != "" {
		fields["mimeType"] = json.StringNode("", e.MimeType)
	}

	return json.ObjectNode("", fields)
}

func ExportParticipantsResponseFromJSON(e *ExportParticipantsResponse, node *json.Node) {
	*e = ExportParticipantsResponse{}
	fields := node.MustObject()

	if val, ok := fields["content"]; ok {
		e.Content = val.MustString()
	}
	if val, ok := fields["filename"]; ok {
		e.Filename = val.MustString()
	}
	if val, ok := fields["mimeType"]; ok {
		e.MimeType = val.MustString()
	}
}

func (e *Entity) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.EntityType != "" {
		fields["entityType"] = json.StringNode("", e.EntityType)
	}
	if e.EntityId != "" {
		fields["entityId"] = json.StringNode("", e.EntityId)
	}

	return json.ObjectNode("", fields)
}

func EntityFromJSON(e *Entity, node *json.Node) {
	*e = Entity{}
	fields := node.MustObject()

	if val, ok := fields["entityType"]; ok {
		e.EntityType = val.MustString()
	}
	if val, ok := fields["entityId"]; ok {
		e.EntityId = val.MustString()
	}
}

func (e *EntityRolesRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Org != nil {
		fields["org"] = e.Org.ToJSON()
	}
	if e.Entity != nil {
		fields["entity"] = e.Entity.ToJSON()
	}

	return json.ObjectNode("", fields)
}

func EntityRolesRequestFromJSON(e *EntityRolesRequest, node *json.Node) {
	*e = EntityRolesRequest{}
	fields := node.MustObject()

	if val, ok := fields["org"]; ok {
		fv := &Entity{}
		EntityFromJSON(fv, val)
		e.Org = fv
	}
	if val, ok := fields["entity"]; ok {
		fv := &Entity{}
		EntityFromJSON(fv, val)
		e.Entity = fv
	}
}

func (e *EntityRolesResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(e.Roles) != 0 {
		arr := make([]*json.Node, len(e.Roles))
		for i, val := range e.Roles {
			arr[i] = json.StringNode("", val)
		}
		fields["roles"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func EntityRolesResponseFromJSON(e *EntityRolesResponse, node *json.Node) {
	*e = EntityRolesResponse{}
	fields := node.MustObject()

	if val, ok := fields["roles"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Roles = arr
	}
}

func (u *UsersWithRoleRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if u.Org != nil {
		fields["org"] = u.Org.ToJSON()
	}
	if u.Role != "" {
		fields["role"] = json.StringNode("", u.Role)
	}

	return json.ObjectNode("", fields)
}

func UsersWithRoleRequestFromJSON(u *UsersWithRoleRequest, node *json.Node) {
	*u = UsersWithRoleRequest{}
	fields := node.MustObject()

	if val, ok := fields["org"]; ok {
		fv := &Entity{}
		EntityFromJSON(fv, val)
		u.Org = fv
	}
	if val, ok := fields["role"]; ok {
		u.Role = val.MustString()
	}
}

func (u *UsersWithRoleResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(u.UsersIds) != 0 {
		arr := make([]*json.Node, len(u.UsersIds))
		for i, val := range u.UsersIds {
			arr[i] = json.StringNode("", val)
		}
		fields["usersIds"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func UsersWithRoleResponseFromJSON(u *UsersWithRoleResponse, node *json.Node) {
	*u = UsersWithRoleResponse{}
	fields := node.MustObject()

	if val, ok := fields["usersIds"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		u.UsersIds = arr
	}
}

func (g *GetCommunityRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.CommunityId != "" {
		fields["communityId"] = json.StringNode("", g.CommunityId)
	}

	return json.ObjectNode("", fields)
}

func GetCommunityRequestFromJSON(g *GetCommunityRequest, node *json.Node) {
	*g = GetCommunityRequest{}
	fields := node.MustObject()

	if val, ok := fields["communityId"]; ok {
		g.CommunityId = val.MustString()
	}
}

func (c *CommunityInfo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.DisplayName != "" {
		fields["displayName"] = json.StringNode("", c.DisplayName)
	}
	if c.Description != "" {
		fields["description"] = json.StringNode("", c.Description)
	}
	if c.AvatarUri != "" {
		fields["avatarUri"] = json.StringNode("", c.AvatarUri)
	}
	if c.BannerUri != "" {
		fields["bannerUri"] = json.StringNode("", c.BannerUri)
	}
	if len(c.Administrators) != 0 {
		arr := make([]*json.Node, len(c.Administrators))
		for i, val := range c.Administrators {
			arr[i] = json.StringNode("", val)
		}
		fields["administrators"] = json.ArrayNode("", arr)
	}
	if c.CountMembers != 0 {
		fields["countMembers"] = json.NumberNode("", float64(c.CountMembers))
	}
	if c.PkgPath != "" {
		fields["pkgPath"] = json.StringNode("", c.PkgPath)
	}

	return json.ObjectNode("", fields)
}

func CommunityInfoFromJSON(c *CommunityInfo, node *json.Node) {
	*c = CommunityInfo{}
	fields := node.MustObject()

	if val, ok := fields["displayName"]; ok {
		c.DisplayName = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		c.Description = val.MustString()
	}
	if val, ok := fields["avatarUri"]; ok {
		c.AvatarUri = val.MustString()
	}
	if val, ok := fields["bannerUri"]; ok {
		c.BannerUri = val.MustString()
	}
	if val, ok := fields["administrators"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		c.Administrators = arr
	}
	if val, ok := fields["countMembers"]; ok {
		c.CountMembers = uint32(val.MustNumeric())
	}
	if val, ok := fields["pkgPath"]; ok {
		c.PkgPath = val.MustString()
	}
}

func (c *CommunitiesInfo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(c.Communities) != 0 {
		arr := make([]*json.Node, len(c.Communities))
		for i, val := range c.Communities {
			arr[i] = val.ToJSON()
		}
		fields["communities"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func CommunitiesInfoFromJSON(c *CommunitiesInfo, node *json.Node) {
	*c = CommunitiesInfo{}
	fields := node.MustObject()

	if val, ok := fields["communities"]; ok {
		jarr := val.MustArray()
		arr := make([]*CommunityInfo, len(jarr))
		for i, val := range jarr {
			fv := &CommunityInfo{}
			CommunityInfoFromJSON(fv, val)
			arr[i] = fv
		}
		c.Communities = arr
	}
}

func (l *ListCommunitiesRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if l.Limit != 0 {
		fields["limit"] = json.NumberNode("", float64(l.Limit))
	}
	if l.Offset != 0 {
		fields["offset"] = json.NumberNode("", float64(l.Offset))
	}

	return json.ObjectNode("", fields)
}

func ListCommunitiesRequestFromJSON(l *ListCommunitiesRequest, node *json.Node) {
	*l = ListCommunitiesRequest{}
	fields := node.MustObject()

	if val, ok := fields["limit"]; ok {
		l.Limit = uint32(val.MustNumeric())
	}
	if val, ok := fields["offset"]; ok {
		l.Offset = uint32(val.MustNumeric())
	}
}

func (l *ListCommunitiesByMemberRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if l.MemberId != "" {
		fields["memberId"] = json.StringNode("", l.MemberId)
	}
	if l.Limit != 0 {
		fields["limit"] = json.NumberNode("", float64(l.Limit))
	}
	if l.Offset != 0 {
		fields["offset"] = json.NumberNode("", float64(l.Offset))
	}

	return json.ObjectNode("", fields)
}

func ListCommunitiesByMemberRequestFromJSON(l *ListCommunitiesByMemberRequest, node *json.Node) {
	*l = ListCommunitiesByMemberRequest{}
	fields := node.MustObject()

	if val, ok := fields["memberId"]; ok {
		l.MemberId = val.MustString()
	}
	if val, ok := fields["limit"]; ok {
		l.Limit = uint32(val.MustNumeric())
	}
	if val, ok := fields["offset"]; ok {
		l.Offset = uint32(val.MustNumeric())
	}
}

func (l *ListCommunitiesByEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if l.EventId != "" {
		fields["eventId"] = json.StringNode("", l.EventId)
	}
	if l.Limit != 0 {
		fields["limit"] = json.NumberNode("", float64(l.Limit))
	}
	if l.Offset != 0 {
		fields["offset"] = json.NumberNode("", float64(l.Offset))
	}

	return json.ObjectNode("", fields)
}

func ListCommunitiesByEventRequestFromJSON(l *ListCommunitiesByEventRequest, node *json.Node) {
	*l = ListCommunitiesByEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		l.EventId = val.MustString()
	}
	if val, ok := fields["limit"]; ok {
		l.Limit = uint32(val.MustNumeric())
	}
	if val, ok := fields["offset"]; ok {
		l.Offset = uint32(val.MustNumeric())
	}
}

func (c *CreateCommunityRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.DisplayName != "" {
		fields["displayName"] = json.StringNode("", c.DisplayName)
	}
	if c.Description != "" {
		fields["description"] = json.StringNode("", c.Description)
	}
	if c.AvatarUri != "" {
		fields["avatarUri"] = json.StringNode("", c.AvatarUri)
	}
	if c.BannerUri != "" {
		fields["bannerUri"] = json.StringNode("", c.BannerUri)
	}
	if len(c.Administrators) != 0 {
		arr := make([]*json.Node, len(c.Administrators))
		for i, val := range c.Administrators {
			arr[i] = json.StringNode("", val)
		}
		fields["administrators"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func CreateCommunityRequestFromJSON(c *CreateCommunityRequest, node *json.Node) {
	*c = CreateCommunityRequest{}
	fields := node.MustObject()

	if val, ok := fields["displayName"]; ok {
		c.DisplayName = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		c.Description = val.MustString()
	}
	if val, ok := fields["avatarUri"]; ok {
		c.AvatarUri = val.MustString()
	}
	if val, ok := fields["bannerUri"]; ok {
		c.BannerUri = val.MustString()
	}
	if val, ok := fields["administrators"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		c.Administrators = arr
	}
}

func (c *CreateCommunityResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.CommunityId != "" {
		fields["communityId"] = json.StringNode("", c.CommunityId)
	}

	return json.ObjectNode("", fields)
}

func CreateCommunityResponseFromJSON(c *CreateCommunityResponse, node *json.Node) {
	*c = CreateCommunityResponse{}
	fields := node.MustObject()

	if val, ok := fields["communityId"]; ok {
		c.CommunityId = val.MustString()
	}
}

func (e *EditCommunityRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.CommunityId != "" {
		fields["communityId"] = json.StringNode("", e.CommunityId)
	}
	if e.DisplayName != "" {
		fields["displayName"] = json.StringNode("", e.DisplayName)
	}
	if e.Description != "" {
		fields["description"] = json.StringNode("", e.Description)
	}
	if e.AvatarUri != "" {
		fields["avatarUri"] = json.StringNode("", e.AvatarUri)
	}
	if e.BannerUri != "" {
		fields["bannerUri"] = json.StringNode("", e.BannerUri)
	}
	if len(e.Administrators) != 0 {
		arr := make([]*json.Node, len(e.Administrators))
		for i, val := range e.Administrators {
			arr[i] = json.StringNode("", val)
		}
		fields["administrators"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func EditCommunityRequestFromJSON(e *EditCommunityRequest, node *json.Node) {
	*e = EditCommunityRequest{}
	fields := node.MustObject()

	if val, ok := fields["communityId"]; ok {
		e.CommunityId = val.MustString()
	}
	if val, ok := fields["displayName"]; ok {
		e.DisplayName = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		e.Description = val.MustString()
	}
	if val, ok := fields["avatarUri"]; ok {
		e.AvatarUri = val.MustString()
	}
	if val, ok := fields["bannerUri"]; ok {
		e.BannerUri = val.MustString()
	}
	if val, ok := fields["administrators"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Administrators = arr
	}
}

func (e *EditCommunityResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func EditCommunityResponseFromJSON(e *EditCommunityResponse, node *json.Node) {
	*e = EditCommunityResponse{}
}

func (g *GetCommunityAdministratorsRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.CommunityId != "" {
		fields["communityId"] = json.StringNode("", g.CommunityId)
	}

	return json.ObjectNode("", fields)
}

func GetCommunityAdministratorsRequestFromJSON(g *GetCommunityAdministratorsRequest, node *json.Node) {
	*g = GetCommunityAdministratorsRequest{}
	fields := node.MustObject()

	if val, ok := fields["communityId"]; ok {
		g.CommunityId = val.MustString()
	}
}

func (g *GetCommunityAdministratorsResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(g.Administrators) != 0 {
		arr := make([]*json.Node, len(g.Administrators))
		for i, val := range g.Administrators {
			arr[i] = json.StringNode("", val)
		}
		fields["administrators"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func GetCommunityAdministratorsResponseFromJSON(g *GetCommunityAdministratorsResponse, node *json.Node) {
	*g = GetCommunityAdministratorsResponse{}
	fields := node.MustObject()

	if val, ok := fields["administrators"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		g.Administrators = arr
	}
}

func (j *JoinCommunityRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if j.CommunityId != "" {
		fields["communityId"] = json.StringNode("", j.CommunityId)
	}

	return json.ObjectNode("", fields)
}

func JoinCommunityRequestFromJSON(j *JoinCommunityRequest, node *json.Node) {
	*j = JoinCommunityRequest{}
	fields := node.MustObject()

	if val, ok := fields["communityId"]; ok {
		j.CommunityId = val.MustString()
	}
}

func (j *JoinCommunityResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func JoinCommunityResponseFromJSON(j *JoinCommunityResponse, node *json.Node) {
	*j = JoinCommunityResponse{}
}

func (l *LeaveCommunityRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if l.CommunityId != "" {
		fields["communityId"] = json.StringNode("", l.CommunityId)
	}

	return json.ObjectNode("", fields)
}

func LeaveCommunityRequestFromJSON(l *LeaveCommunityRequest, node *json.Node) {
	*l = LeaveCommunityRequest{}
	fields := node.MustObject()

	if val, ok := fields["communityId"]; ok {
		l.CommunityId = val.MustString()
	}
}

func (l *LeaveCommunityResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func LeaveCommunityResponseFromJSON(l *LeaveCommunityResponse, node *json.Node) {
	*l = LeaveCommunityResponse{}
}

func (a *AddEventToCommunityRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.CommunityId != "" {
		fields["communityId"] = json.StringNode("", a.CommunityId)
	}
	if a.EventId != "" {
		fields["eventId"] = json.StringNode("", a.EventId)
	}

	return json.ObjectNode("", fields)
}

func AddEventToCommunityRequestFromJSON(a *AddEventToCommunityRequest, node *json.Node) {
	*a = AddEventToCommunityRequest{}
	fields := node.MustObject()

	if val, ok := fields["communityId"]; ok {
		a.CommunityId = val.MustString()
	}
	if val, ok := fields["eventId"]; ok {
		a.EventId = val.MustString()
	}
}

func (a *AddEventToCommunityResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func AddEventToCommunityResponseFromJSON(a *AddEventToCommunityResponse, node *json.Node) {
	*a = AddEventToCommunityResponse{}
}

func (r *RemoveEventFromCommunityRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if r.CommunityId != "" {
		fields["communityId"] = json.StringNode("", r.CommunityId)
	}
	if r.EventId != "" {
		fields["eventId"] = json.StringNode("", r.EventId)
	}

	return json.ObjectNode("", fields)
}

func RemoveEventFromCommunityRequestFromJSON(r *RemoveEventFromCommunityRequest, node *json.Node) {
	*r = RemoveEventFromCommunityRequest{}
	fields := node.MustObject()

	if val, ok := fields["communityId"]; ok {
		r.CommunityId = val.MustString()
	}
	if val, ok := fields["eventId"]; ok {
		r.EventId = val.MustString()
	}
}

func (r *RemoveEventFromCommunityResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func RemoveEventFromCommunityResponseFromJSON(r *RemoveEventFromCommunityResponse, node *json.Node) {
	*r = RemoveEventFromCommunityResponse{}
}
