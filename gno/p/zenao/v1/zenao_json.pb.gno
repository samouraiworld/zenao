// Code generated by protoc-gen-gno. DO NOT EDIT.

package zenaov1

import (
	"errors"
	"strconv"

	"gno.land/p/demo/json"
)

func (e *EditUserRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.DisplayName != "" {
		fields["displayName"] = json.StringNode("", e.DisplayName)
	}
	if e.Bio != "" {
		fields["bio"] = json.StringNode("", e.Bio)
	}
	if e.AvatarUri != "" {
		fields["avatarUri"] = json.StringNode("", e.AvatarUri)
	}

	return json.ObjectNode("", fields)
}

func (e *EditUserRequest) FromJSON(node *json.Node) {
	*e = EditUserRequest{}
	fields := node.MustObject()

	if val, ok := fields["displayName"]; ok {
		e.DisplayName = val.MustString()
	}
	if val, ok := fields["bio"]; ok {
		e.Bio = val.MustString()
	}
	if val, ok := fields["avatarUri"]; ok {
		e.AvatarUri = val.MustString()
	}
}

func (e *EditUserResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Id != "" {
		fields["id"] = json.StringNode("", e.Id)
	}

	return json.ObjectNode("", fields)
}

func (e *EditUserResponse) FromJSON(node *json.Node) {
	*e = EditUserResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		e.Id = val.MustString()
	}
}

func (g *GetUserAddressRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func (g *GetUserAddressRequest) FromJSON(node *json.Node) {
	*g = GetUserAddressRequest{}
}

func (g *GetUserAddressResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.Address != "" {
		fields["address"] = json.StringNode("", g.Address)
	}

	return json.ObjectNode("", fields)
}

func (g *GetUserAddressResponse) FromJSON(node *json.Node) {
	*g = GetUserAddressResponse{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		g.Address = val.MustString()
	}
}

func (c *CreateEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.Title != "" {
		fields["title"] = json.StringNode("", c.Title)
	}
	if c.Description != "" {
		fields["description"] = json.StringNode("", c.Description)
	}
	if c.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", c.ImageUri)
	}
	if c.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatUint(c.StartDate, 10))
	}
	if c.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatUint(c.EndDate, 10))
	}
	if c.TicketPrice != 0 {
		fields["ticketPrice"] = json.NumberNode("", float64(c.TicketPrice))
	}
	if c.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(c.Capacity))
	}
	if c.Location != nil {
		fields["location"] = c.Location.ToJSON()
	}

	return json.ObjectNode("", fields)
}

func (c *CreateEventRequest) FromJSON(node *json.Node) {
	*c = CreateEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		c.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		c.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		c.ImageUri = val.MustString()
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		c.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		c.EndDate = fv
	}
	if val, ok := fields["ticketPrice"]; ok {
		c.TicketPrice = val.MustNumeric()
	}
	if val, ok := fields["capacity"]; ok {
		c.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		fv.FromJSON(val)
		c.Location = fv
	}
}

func (c *CreateEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.Id != "" {
		fields["id"] = json.StringNode("", c.Id)
	}

	return json.ObjectNode("", fields)
}

func (c *CreateEventResponse) FromJSON(node *json.Node) {
	*c = CreateEventResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		c.Id = val.MustString()
	}
}

func (e *EditEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.EventId != "" {
		fields["eventId"] = json.StringNode("", e.EventId)
	}
	if e.Title != "" {
		fields["title"] = json.StringNode("", e.Title)
	}
	if e.Description != "" {
		fields["description"] = json.StringNode("", e.Description)
	}
	if e.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", e.ImageUri)
	}
	if e.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatUint(e.StartDate, 10))
	}
	if e.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatUint(e.EndDate, 10))
	}
	if e.TicketPrice != 0 {
		fields["ticketPrice"] = json.NumberNode("", float64(e.TicketPrice))
	}
	if e.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(e.Capacity))
	}
	if e.Location != nil {
		fields["location"] = e.Location.ToJSON()
	}

	return json.ObjectNode("", fields)
}

func (e *EditEventRequest) FromJSON(node *json.Node) {
	*e = EditEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		e.EventId = val.MustString()
	}
	if val, ok := fields["title"]; ok {
		e.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		e.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		e.ImageUri = val.MustString()
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.EndDate = fv
	}
	if val, ok := fields["ticketPrice"]; ok {
		e.TicketPrice = val.MustNumeric()
	}
	if val, ok := fields["capacity"]; ok {
		e.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		fv.FromJSON(val)
		e.Location = fv
	}
}

func (e *EditEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Id != "" {
		fields["id"] = json.StringNode("", e.Id)
	}

	return json.ObjectNode("", fields)
}

func (e *EditEventResponse) FromJSON(node *json.Node) {
	*e = EditEventResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		e.Id = val.MustString()
	}
}

func (p *ParticipateRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.EventId != "" {
		fields["eventId"] = json.StringNode("", p.EventId)
	}
	if p.Email != "" {
		fields["email"] = json.StringNode("", p.Email)
	}

	return json.ObjectNode("", fields)
}

func (p *ParticipateRequest) FromJSON(node *json.Node) {
	*p = ParticipateRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		p.EventId = val.MustString()
	}
	if val, ok := fields["email"]; ok {
		p.Email = val.MustString()
	}
}

func (p *ParticipateResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.TicketSecret != "" {
		fields["ticketSecret"] = json.StringNode("", p.TicketSecret)
	}

	return json.ObjectNode("", fields)
}

func (p *ParticipateResponse) FromJSON(node *json.Node) {
	*p = ParticipateResponse{}
	fields := node.MustObject()

	if val, ok := fields["ticketSecret"]; ok {
		p.TicketSecret = val.MustString()
	}
}

func (e *EventLocation) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.VenueName != "" {
		fields["venueName"] = json.StringNode("", e.VenueName)
	}
	if e.Instructions != "" {
		fields["instructions"] = json.StringNode("", e.Instructions)
	}

	switch val := e.Address.(type) {
	case *AddressGeo:
		fields["geo"] = val.ToJSON()
	case *AddressVirtual:
		fields["virtual"] = val.ToJSON()
	case *AddressCustom:
		fields["custom"] = val.ToJSON()
	default:
		panic(errors.New("unknown address variant"))
	}

	return json.ObjectNode("", fields)
}

func (e *EventLocation) FromJSON(node *json.Node) {
	*e = EventLocation{}
	fields := node.MustObject()

	if val, ok := fields["venueName"]; ok {
		e.VenueName = val.MustString()
	}
	if val, ok := fields["instructions"]; ok {
		e.Instructions = val.MustString()
	}

	variantFieldNames := []string{"geo", "virtual", "custom"}
	var selectedVariant *json.Node
	var selectedVariantName string
	for _, variantName := range variantFieldNames {
		if variant, ok := fields[variantName]; ok {
			selectedVariantName = variantName
			selectedVariant = variant
		}
		break
	}
	switch selectedVariantName {
	case "geo":
		n := &AddressGeo{}
		n.FromJSON(selectedVariant)
		e.Address = n
	case "virtual":
		n := &AddressVirtual{}
		n.FromJSON(selectedVariant)
		e.Address = n
	case "custom":
		n := &AddressCustom{}
		n.FromJSON(selectedVariant)
		e.Address = n
	default:
		panic(errors.New("address variant not found"))
	}
}

func (a *AddressVirtual) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Uri != "" {
		fields["uri"] = json.StringNode("", a.Uri)
	}

	return json.ObjectNode("", fields)
}

func (a *AddressVirtual) FromJSON(node *json.Node) {
	*a = AddressVirtual{}
	fields := node.MustObject()

	if val, ok := fields["uri"]; ok {
		a.Uri = val.MustString()
	}
}

func (a *AddressGeo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Address != "" {
		fields["address"] = json.StringNode("", a.Address)
	}
	if a.Lat != 0 {
		fields["lat"] = json.NumberNode("", float64(a.Lat))
	}
	if a.Lng != 0 {
		fields["lng"] = json.NumberNode("", float64(a.Lng))
	}
	if a.Size != 0 {
		fields["size"] = json.NumberNode("", float64(a.Size))
	}

	return json.ObjectNode("", fields)
}

func (a *AddressGeo) FromJSON(node *json.Node) {
	*a = AddressGeo{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		a.Address = val.MustString()
	}
	if val, ok := fields["lat"]; ok {
		a.Lat = float32(val.MustNumeric())
	}
	if val, ok := fields["lng"]; ok {
		a.Lng = float32(val.MustNumeric())
	}
	if val, ok := fields["size"]; ok {
		a.Size = float32(val.MustNumeric())
	}
}

func (a *AddressCustom) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Address != "" {
		fields["address"] = json.StringNode("", a.Address)
	}
	if a.Timezone != "" {
		fields["timezone"] = json.StringNode("", a.Timezone)
	}

	return json.ObjectNode("", fields)
}

func (a *AddressCustom) FromJSON(node *json.Node) {
	*a = AddressCustom{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		a.Address = val.MustString()
	}
	if val, ok := fields["timezone"]; ok {
		a.Timezone = val.MustString()
	}
}

func (e *EventInfo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Title != "" {
		fields["title"] = json.StringNode("", e.Title)
	}
	if e.Description != "" {
		fields["description"] = json.StringNode("", e.Description)
	}
	if e.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", e.ImageUri)
	}
	if e.Creator != "" {
		fields["creator"] = json.StringNode("", e.Creator)
	}
	if e.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatInt(e.StartDate, 10))
	}
	if e.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatInt(e.EndDate, 10))
	}
	if e.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(e.Capacity))
	}
	if e.Location != nil {
		fields["location"] = e.Location.ToJSON()
	}
	if e.Participants != 0 {
		fields["participants"] = json.NumberNode("", float64(e.Participants))
	}
	if e.PkgPath != "" {
		fields["pkgPath"] = json.StringNode("", e.PkgPath)
	}

	return json.ObjectNode("", fields)
}

func (e *EventInfo) FromJSON(node *json.Node) {
	*e = EventInfo{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		e.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		e.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		e.ImageUri = val.MustString()
	}
	if val, ok := fields["creator"]; ok {
		e.Creator = val.MustString()
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.EndDate = fv
	}
	if val, ok := fields["capacity"]; ok {
		e.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		fv.FromJSON(val)
		e.Location = fv
	}
	if val, ok := fields["participants"]; ok {
		e.Participants = uint32(val.MustNumeric())
	}
	if val, ok := fields["pkgPath"]; ok {
		e.PkgPath = val.MustString()
	}
}

func (b *BatchProfileField) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if b.Type != "" {
		fields["type"] = json.StringNode("", b.Type)
	}
	if b.Key != "" {
		fields["key"] = json.StringNode("", b.Key)
	}

	return json.ObjectNode("", fields)
}

func (b *BatchProfileField) FromJSON(node *json.Node) {
	*b = BatchProfileField{}
	fields := node.MustObject()

	if val, ok := fields["type"]; ok {
		b.Type = val.MustString()
	}
	if val, ok := fields["key"]; ok {
		b.Key = val.MustString()
	}
}

func (b *BatchProfileRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(b.Fields) != 0 {
		arr := make([]*json.Node, len(b.Fields))
		for i, val := range b.Fields {
			arr[i] = val.ToJSON()
		}
		fields["fields"] = json.ArrayNode("", arr)
	}
	if len(b.Addresses) != 0 {
		arr := make([]*json.Node, len(b.Addresses))
		for i, val := range b.Addresses {
			arr[i] = json.StringNode("", val)
		}
		fields["addresses"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func (b *BatchProfileRequest) FromJSON(node *json.Node) {
	*b = BatchProfileRequest{}
	fields := node.MustObject()

	if val, ok := fields["fields"]; ok {
		jarr := val.MustArray()
		arr := make([]*BatchProfileField, len(jarr))
		for i, val := range jarr {
			fv := &BatchProfileField{}
			fv.FromJSON(val)
			arr[i] = fv
		}
		b.Fields = arr
	}
	if val, ok := fields["addresses"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		b.Addresses = arr
	}
}

func (p *PostGeoLoc) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.Lat != 0 {
		fields["lat"] = json.NumberNode("", float64(p.Lat))
	}
	if p.Lng != 0 {
		fields["lng"] = json.NumberNode("", float64(p.Lng))
	}

	return json.ObjectNode("", fields)
}

func (p *PostGeoLoc) FromJSON(node *json.Node) {
	*p = PostGeoLoc{}
	fields := node.MustObject()

	if val, ok := fields["lat"]; ok {
		p.Lat = float32(val.MustNumeric())
	}
	if val, ok := fields["lng"]; ok {
		p.Lng = float32(val.MustNumeric())
	}
}

func (p *PostID) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.LocalId != "" {
		fields["localId"] = json.StringNode("", p.LocalId)
	}
	if p.FeedId != "" {
		fields["feedId"] = json.StringNode("", p.FeedId)
	}
	if p.NetworkId != "" {
		fields["networkId"] = json.StringNode("", p.NetworkId)
	}

	return json.ObjectNode("", fields)
}

func (p *PostID) FromJSON(node *json.Node) {
	*p = PostID{}
	fields := node.MustObject()

	if val, ok := fields["localId"]; ok {
		p.LocalId = val.MustString()
	}
	if val, ok := fields["feedId"]; ok {
		p.FeedId = val.MustString()
	}
	if val, ok := fields["networkId"]; ok {
		p.NetworkId = val.MustString()
	}
}

func (p *PostCommon) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.ChannelId != "" {
		fields["channelId"] = json.StringNode("", p.ChannelId)
	}
	if p.Author != "" {
		fields["author"] = json.StringNode("", p.Author)
	}
	if p.ParentId != nil {
		fields["parentId"] = p.ParentId.ToJSON()
	}
	if p.Loc != nil {
		fields["loc"] = p.Loc.ToJSON()
	}
	if p.CreatedAt != 0 {
		fields["createdAt"] = json.StringNode("", strconv.FormatInt(p.CreatedAt, 10))
	}
	if p.UpdatedAt != 0 {
		fields["updatedAt"] = json.StringNode("", strconv.FormatInt(p.UpdatedAt, 10))
	}
	if p.DeletedAt != 0 {
		fields["deletedAt"] = json.StringNode("", strconv.FormatInt(p.DeletedAt, 10))
	}

	return json.ObjectNode("", fields)
}

func (p *PostCommon) FromJSON(node *json.Node) {
	*p = PostCommon{}
	fields := node.MustObject()

	if val, ok := fields["channelId"]; ok {
		p.ChannelId = val.MustString()
	}
	if val, ok := fields["author"]; ok {
		p.Author = val.MustString()
	}
	if val, ok := fields["parentId"]; ok {
		fv := &PostID{}
		fv.FromJSON(val)
		p.ParentId = fv
	}
	if val, ok := fields["loc"]; ok {
		fv := &PostGeoLoc{}
		fv.FromJSON(val)
		p.Loc = fv
	}
	if val, ok := fields["createdAt"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64);
		if err != nil {
			panic(err)
		}
		p.CreatedAt = fv
	}
	if val, ok := fields["updatedAt"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64);
		if err != nil {
			panic(err)
		}
		p.UpdatedAt = fv
	}
	if val, ok := fields["deletedAt"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64);
		if err != nil {
			panic(err)
		}
		p.DeletedAt = fv
	}
}

func (s *StandardPost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if s.Common != nil {
		fields["common"] = s.Common.ToJSON()
	}
	if s.Content != "" {
		fields["content"] = json.StringNode("", s.Content)
	}

	return json.ObjectNode("", fields)
}

func (s *StandardPost) FromJSON(node *json.Node) {
	*s = StandardPost{}
	fields := node.MustObject()

	if val, ok := fields["common"]; ok {
		fv := &PostCommon{}
		fv.FromJSON(val)
		s.Common = fv
	}
	if val, ok := fields["content"]; ok {
		s.Content = val.MustString()
	}
}

func (a *ArticlePost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Common != nil {
		fields["common"] = a.Common.ToJSON()
	}
	if a.Title != "" {
		fields["title"] = json.StringNode("", a.Title)
	}
	if a.PreviewText != "" {
		fields["previewText"] = json.StringNode("", a.PreviewText)
	}
	if a.PreviewImageUri != "" {
		fields["previewImageUri"] = json.StringNode("", a.PreviewImageUri)
	}
	if a.Content != "" {
		fields["content"] = json.StringNode("", a.Content)
	}

	return json.ObjectNode("", fields)
}

func (a *ArticlePost) FromJSON(node *json.Node) {
	*a = ArticlePost{}
	fields := node.MustObject()

	if val, ok := fields["common"]; ok {
		fv := &PostCommon{}
		fv.FromJSON(val)
		a.Common = fv
	}
	if val, ok := fields["title"]; ok {
		a.Title = val.MustString()
	}
	if val, ok := fields["previewText"]; ok {
		a.PreviewText = val.MustString()
	}
	if val, ok := fields["previewImageUri"]; ok {
		a.PreviewImageUri = val.MustString()
	}
	if val, ok := fields["content"]; ok {
		a.Content = val.MustString()
	}
}

func (l *LinkPost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if l.Common != nil {
		fields["common"] = l.Common.ToJSON()
	}
	if l.Uri != "" {
		fields["uri"] = json.StringNode("", l.Uri)
	}

	return json.ObjectNode("", fields)
}

func (l *LinkPost) FromJSON(node *json.Node) {
	*l = LinkPost{}
	fields := node.MustObject()

	if val, ok := fields["common"]; ok {
		fv := &PostCommon{}
		fv.FromJSON(val)
		l.Common = fv
	}
	if val, ok := fields["uri"]; ok {
		l.Uri = val.MustString()
	}
}

func (i *ImagePost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if i.Common != nil {
		fields["common"] = i.Common.ToJSON()
	}
	if i.Description != "" {
		fields["description"] = json.StringNode("", i.Description)
	}
	if i.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", i.ImageUri)
	}

	return json.ObjectNode("", fields)
}

func (i *ImagePost) FromJSON(node *json.Node) {
	*i = ImagePost{}
	fields := node.MustObject()

	if val, ok := fields["common"]; ok {
		fv := &PostCommon{}
		fv.FromJSON(val)
		i.Common = fv
	}
	if val, ok := fields["description"]; ok {
		i.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		i.ImageUri = val.MustString()
	}
}

func (v *VideoPost) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if v.Common != nil {
		fields["common"] = v.Common.ToJSON()
	}
	if v.Description != "" {
		fields["description"] = json.StringNode("", v.Description)
	}
	if v.VideoUri != "" {
		fields["videoUri"] = json.StringNode("", v.VideoUri)
	}
	if v.ThumbnailImageUri != "" {
		fields["thumbnailImageUri"] = json.StringNode("", v.ThumbnailImageUri)
	}

	return json.ObjectNode("", fields)
}

func (v *VideoPost) FromJSON(node *json.Node) {
	*v = VideoPost{}
	fields := node.MustObject()

	if val, ok := fields["common"]; ok {
		fv := &PostCommon{}
		fv.FromJSON(val)
		v.Common = fv
	}
	if val, ok := fields["description"]; ok {
		v.Description = val.MustString()
	}
	if val, ok := fields["videoUri"]; ok {
		v.VideoUri = val.MustString()
	}
	if val, ok := fields["thumbnailImageUri"]; ok {
		v.ThumbnailImageUri = val.MustString()
	}
}

func (r *Reaction) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if r.PostId != nil {
		fields["postId"] = r.PostId.ToJSON()
	}
	if r.Icon != "" {
		fields["icon"] = json.StringNode("", r.Icon)
	}
	if r.UserId != "" {
		fields["userId"] = json.StringNode("", r.UserId)
	}

	return json.ObjectNode("", fields)
}

func (r *Reaction) FromJSON(node *json.Node) {
	*r = Reaction{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		fv := &PostID{}
		fv.FromJSON(val)
		r.PostId = fv
	}
	if val, ok := fields["icon"]; ok {
		r.Icon = val.MustString()
	}
	if val, ok := fields["userId"]; ok {
		r.UserId = val.MustString()
	}
}

func (t *Tip) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if t.PostLocalId != "" {
		fields["postLocalId"] = json.StringNode("", t.PostLocalId)
	}
	if t.Denom != "" {
		fields["denom"] = json.StringNode("", t.Denom)
	}
	if t.Amount != 0 {
		fields["amount"] = json.StringNode("", strconv.FormatInt(t.Amount, 10))
	}

	return json.ObjectNode("", fields)
}

func (t *Tip) FromJSON(node *json.Node) {
	*t = Tip{}
	fields := node.MustObject()

	if val, ok := fields["postLocalId"]; ok {
		t.PostLocalId = val.MustString()
	}
	if val, ok := fields["denom"]; ok {
		t.Denom = val.MustString()
	}
	if val, ok := fields["amount"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64);
		if err != nil {
			panic(err)
		}
		t.Amount = fv
	}
}

func (p *Post) ToJSON() *json.Node {
	fields := map[string]*json.Node{}


	post := map[string]*json.Node{}
	switch val := p.Post.(type) {
	case *StandardPost:
		post["case"] = json.StringNode("", "standard")
		post["value"] = val.ToJSON()
	case *ArticlePost:
		post["case"] = json.StringNode("", "article")
		post["value"] = val.ToJSON()
	case *LinkPost:
		post["case"] = json.StringNode("", "link")
		post["value"] = val.ToJSON()
	case *ImagePost:
		post["case"] = json.StringNode("", "image")
		post["value"] = val.ToJSON()
	case *VideoPost:
		post["case"] = json.StringNode("", "video")
		post["value"] = val.ToJSON()
	default:
		panic(errors.New("unknown post variant"))
	}
	fields["post"] = json.ObjectNode("", post)

	return json.ObjectNode("", fields)
}

func (p *Post) FromJSON(node *json.Node) {
	*p = Post{}
	fields := node.MustObject()


	if union, ok := fields["post"]; ok {
		obj := union.MustObject()
		kind := obj["case"].MustString()
		val := obj["value"]
		switch kind {
		case "standard":
			n := &StandardPost{}
			n.FromJSON(val)
			p.Post = n
		case "article":
			n := &ArticlePost{}
			n.FromJSON(val)
			p.Post = n
		case "link":
			n := &LinkPost{}
			n.FromJSON(val)
			p.Post = n
		case "image":
			n := &ImagePost{}
			n.FromJSON(val)
			p.Post = n
		case "video":
			n := &VideoPost{}
			n.FromJSON(val)
			p.Post = n
		default:
			panic(errors.New("unknown post variant"))
		}
	}
}

func (s *SocialFeed) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if s.Id != "" {
		fields["id"] = json.StringNode("", s.Id)
	}

	return json.ObjectNode("", fields)
}

func (s *SocialFeed) FromJSON(node *json.Node) {
	*s = SocialFeed{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		s.Id = val.MustString()
	}
}
