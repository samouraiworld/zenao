// Code generated by protoc-gen-gno. DO NOT EDIT.

package zenaov1

import (
	"errors"
	"strconv"

	"gno.land/p/demo/json"
	v1 "gno.land/p/zenao/polls/v1"
)

func (h *HealthRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func (h *HealthRequest) FromJSON(node *json.Node) {
	*h = HealthRequest{}
}

func (h *HealthResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if h.Maintenance != false {
		fields["maintenance"] = json.BoolNode("", h.Maintenance)
	}

	return json.ObjectNode("", fields)
}

func (h *HealthResponse) FromJSON(node *json.Node) {
	*h = HealthResponse{}
	fields := node.MustObject()

	if val, ok := fields["maintenance"]; ok {
		h.Maintenance = val.MustBool()
	}
}

func (e *EditUserRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.DisplayName != "" {
		fields["displayName"] = json.StringNode("", e.DisplayName)
	}
	if e.Bio != "" {
		fields["bio"] = json.StringNode("", e.Bio)
	}
	if e.AvatarUri != "" {
		fields["avatarUri"] = json.StringNode("", e.AvatarUri)
	}

	return json.ObjectNode("", fields)
}

func (e *EditUserRequest) FromJSON(node *json.Node) {
	*e = EditUserRequest{}
	fields := node.MustObject()

	if val, ok := fields["displayName"]; ok {
		e.DisplayName = val.MustString()
	}
	if val, ok := fields["bio"]; ok {
		e.Bio = val.MustString()
	}
	if val, ok := fields["avatarUri"]; ok {
		e.AvatarUri = val.MustString()
	}
}

func (e *EditUserResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Id != "" {
		fields["id"] = json.StringNode("", e.Id)
	}

	return json.ObjectNode("", fields)
}

func (e *EditUserResponse) FromJSON(node *json.Node) {
	*e = EditUserResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		e.Id = val.MustString()
	}
}

func (g *GetUserAddressRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func (g *GetUserAddressRequest) FromJSON(node *json.Node) {
	*g = GetUserAddressRequest{}
}

func (g *GetUserAddressResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.Address != "" {
		fields["address"] = json.StringNode("", g.Address)
	}

	return json.ObjectNode("", fields)
}

func (g *GetUserAddressResponse) FromJSON(node *json.Node) {
	*g = GetUserAddressResponse{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		g.Address = val.MustString()
	}
}

func (c *CreateEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.Title != "" {
		fields["title"] = json.StringNode("", c.Title)
	}
	if c.Description != "" {
		fields["description"] = json.StringNode("", c.Description)
	}
	if c.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", c.ImageUri)
	}
	if c.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatUint(c.StartDate, 10))
	}
	if c.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatUint(c.EndDate, 10))
	}
	if c.TicketPrice != 0 {
		fields["ticketPrice"] = json.NumberNode("", float64(c.TicketPrice))
	}
	if c.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(c.Capacity))
	}
	if c.Location != nil {
		fields["location"] = c.Location.ToJSON()
	}
	if c.Password != "" {
		fields["password"] = json.StringNode("", c.Password)
	}
	if len(c.Organizers) != 0 {
		arr := make([]*json.Node, len(c.Organizers))
		for i, val := range c.Organizers {
			arr[i] = json.StringNode("", val)
		}
		fields["organizers"] = json.ArrayNode("", arr)
	}
	if len(c.Gatekeepers) != 0 {
		arr := make([]*json.Node, len(c.Gatekeepers))
		for i, val := range c.Gatekeepers {
			arr[i] = json.StringNode("", val)
		}
		fields["gatekeepers"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func (c *CreateEventRequest) FromJSON(node *json.Node) {
	*c = CreateEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		c.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		c.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		c.ImageUri = val.MustString()
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		c.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		c.EndDate = fv
	}
	if val, ok := fields["ticketPrice"]; ok {
		c.TicketPrice = val.MustNumeric()
	}
	if val, ok := fields["capacity"]; ok {
		c.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		fv.FromJSON(val)
		c.Location = fv
	}
	if val, ok := fields["password"]; ok {
		c.Password = val.MustString()
	}
	if val, ok := fields["organizers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		c.Organizers = arr
	}
	if val, ok := fields["gatekeepers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		c.Gatekeepers = arr
	}
}

func (c *CreateEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.Id != "" {
		fields["id"] = json.StringNode("", c.Id)
	}

	return json.ObjectNode("", fields)
}

func (c *CreateEventResponse) FromJSON(node *json.Node) {
	*c = CreateEventResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		c.Id = val.MustString()
	}
}

func (e *EditEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.EventId != "" {
		fields["eventId"] = json.StringNode("", e.EventId)
	}
	if e.Title != "" {
		fields["title"] = json.StringNode("", e.Title)
	}
	if e.Description != "" {
		fields["description"] = json.StringNode("", e.Description)
	}
	if e.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", e.ImageUri)
	}
	if e.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatUint(e.StartDate, 10))
	}
	if e.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatUint(e.EndDate, 10))
	}
	if e.TicketPrice != 0 {
		fields["ticketPrice"] = json.NumberNode("", float64(e.TicketPrice))
	}
	if e.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(e.Capacity))
	}
	if e.Location != nil {
		fields["location"] = e.Location.ToJSON()
	}
	if e.Password != "" {
		fields["password"] = json.StringNode("", e.Password)
	}
	if e.UpdatePassword != false {
		fields["updatePassword"] = json.BoolNode("", e.UpdatePassword)
	}
	if len(e.Organizers) != 0 {
		arr := make([]*json.Node, len(e.Organizers))
		for i, val := range e.Organizers {
			arr[i] = json.StringNode("", val)
		}
		fields["organizers"] = json.ArrayNode("", arr)
	}
	if len(e.Gatekeepers) != 0 {
		arr := make([]*json.Node, len(e.Gatekeepers))
		for i, val := range e.Gatekeepers {
			arr[i] = json.StringNode("", val)
		}
		fields["gatekeepers"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func (e *EditEventRequest) FromJSON(node *json.Node) {
	*e = EditEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		e.EventId = val.MustString()
	}
	if val, ok := fields["title"]; ok {
		e.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		e.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		e.ImageUri = val.MustString()
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.EndDate = fv
	}
	if val, ok := fields["ticketPrice"]; ok {
		e.TicketPrice = val.MustNumeric()
	}
	if val, ok := fields["capacity"]; ok {
		e.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		fv.FromJSON(val)
		e.Location = fv
	}
	if val, ok := fields["password"]; ok {
		e.Password = val.MustString()
	}
	if val, ok := fields["updatePassword"]; ok {
		e.UpdatePassword = val.MustBool()
	}
	if val, ok := fields["organizers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Organizers = arr
	}
	if val, ok := fields["gatekeepers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Gatekeepers = arr
	}
}

func (e *EditEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Id != "" {
		fields["id"] = json.StringNode("", e.Id)
	}

	return json.ObjectNode("", fields)
}

func (e *EditEventResponse) FromJSON(node *json.Node) {
	*e = EditEventResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		e.Id = val.MustString()
	}
}

func (g *GetEventGatekeepersRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.EventId != "" {
		fields["eventId"] = json.StringNode("", g.EventId)
	}

	return json.ObjectNode("", fields)
}

func (g *GetEventGatekeepersRequest) FromJSON(node *json.Node) {
	*g = GetEventGatekeepersRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		g.EventId = val.MustString()
	}
}

func (g *GetEventGatekeepersResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(g.Gatekeepers) != 0 {
		arr := make([]*json.Node, len(g.Gatekeepers))
		for i, val := range g.Gatekeepers {
			arr[i] = json.StringNode("", val)
		}
		fields["gatekeepers"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func (g *GetEventGatekeepersResponse) FromJSON(node *json.Node) {
	*g = GetEventGatekeepersResponse{}
	fields := node.MustObject()

	if val, ok := fields["gatekeepers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		g.Gatekeepers = arr
	}
}

func (v *ValidatePasswordRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if v.EventId != "" {
		fields["eventId"] = json.StringNode("", v.EventId)
	}
	if v.Password != "" {
		fields["password"] = json.StringNode("", v.Password)
	}

	return json.ObjectNode("", fields)
}

func (v *ValidatePasswordRequest) FromJSON(node *json.Node) {
	*v = ValidatePasswordRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		v.EventId = val.MustString()
	}
	if val, ok := fields["password"]; ok {
		v.Password = val.MustString()
	}
}

func (v *ValidatePasswordResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if v.Valid != false {
		fields["valid"] = json.BoolNode("", v.Valid)
	}

	return json.ObjectNode("", fields)
}

func (v *ValidatePasswordResponse) FromJSON(node *json.Node) {
	*v = ValidatePasswordResponse{}
	fields := node.MustObject()

	if val, ok := fields["valid"]; ok {
		v.Valid = val.MustBool()
	}
}

func (p *ParticipateRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.EventId != "" {
		fields["eventId"] = json.StringNode("", p.EventId)
	}
	if p.Email != "" {
		fields["email"] = json.StringNode("", p.Email)
	}
	if len(p.Guests) != 0 {
		arr := make([]*json.Node, len(p.Guests))
		for i, val := range p.Guests {
			arr[i] = json.StringNode("", val)
		}
		fields["guests"] = json.ArrayNode("", arr)
	}
	if p.Password != "" {
		fields["password"] = json.StringNode("", p.Password)
	}

	return json.ObjectNode("", fields)
}

func (p *ParticipateRequest) FromJSON(node *json.Node) {
	*p = ParticipateRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		p.EventId = val.MustString()
	}
	if val, ok := fields["email"]; ok {
		p.Email = val.MustString()
	}
	if val, ok := fields["guests"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		p.Guests = arr
	}
	if val, ok := fields["password"]; ok {
		p.Password = val.MustString()
	}
}

func (c *CancelParticipationRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.EventId != "" {
		fields["eventId"] = json.StringNode("", c.EventId)
	}

	return json.ObjectNode("", fields)
}

func (c *CancelParticipationRequest) FromJSON(node *json.Node) {
	*c = CancelParticipationRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		c.EventId = val.MustString()
	}
}

func (c *CancelParticipationResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func (c *CancelParticipationResponse) FromJSON(node *json.Node) {
	*c = CancelParticipationResponse{}
}

func (p *ParticipateResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.TicketSecret != "" {
		fields["ticketSecret"] = json.StringNode("", p.TicketSecret)
	}

	return json.ObjectNode("", fields)
}

func (p *ParticipateResponse) FromJSON(node *json.Node) {
	*p = ParticipateResponse{}
	fields := node.MustObject()

	if val, ok := fields["ticketSecret"]; ok {
		p.TicketSecret = val.MustString()
	}
}

func (b *BroadcastEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if b.EventId != "" {
		fields["eventId"] = json.StringNode("", b.EventId)
	}
	if b.Message != "" {
		fields["message"] = json.StringNode("", b.Message)
	}

	return json.ObjectNode("", fields)
}

func (b *BroadcastEventRequest) FromJSON(node *json.Node) {
	*b = BroadcastEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		b.EventId = val.MustString()
	}
	if val, ok := fields["message"]; ok {
		b.Message = val.MustString()
	}
}

func (b *BroadcastEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func (b *BroadcastEventResponse) FromJSON(node *json.Node) {
	*b = BroadcastEventResponse{}
}

func (e *EventLocation) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.VenueName != "" {
		fields["venueName"] = json.StringNode("", e.VenueName)
	}
	if e.Instructions != "" {
		fields["instructions"] = json.StringNode("", e.Instructions)
	}

	switch val := e.Address.(type) {
	case *AddressGeo:
		fields["geo"] = val.ToJSON()
	case *AddressVirtual:
		fields["virtual"] = val.ToJSON()
	case *AddressCustom:
		fields["custom"] = val.ToJSON()
	default:
		panic(errors.New("unknown address variant"))
	}

	return json.ObjectNode("", fields)
}

func (e *EventLocation) FromJSON(node *json.Node) {
	*e = EventLocation{}
	fields := node.MustObject()

	if val, ok := fields["venueName"]; ok {
		e.VenueName = val.MustString()
	}
	if val, ok := fields["instructions"]; ok {
		e.Instructions = val.MustString()
	}

	variantFieldNames := []string{"geo", "virtual", "custom"}
	var selectedVariant *json.Node
	var selectedVariantName string
	for _, variantName := range variantFieldNames {
		if variant, ok := fields[variantName]; ok {
			selectedVariantName = variantName
			selectedVariant = variant
		}
		break
	}
	switch selectedVariantName {
	case "geo":
		n := &AddressGeo{}
		n.FromJSON(selectedVariant)
		e.Address = n
	case "virtual":
		n := &AddressVirtual{}
		n.FromJSON(selectedVariant)
		e.Address = n
	case "custom":
		n := &AddressCustom{}
		n.FromJSON(selectedVariant)
		e.Address = n
	default:
		panic(errors.New("address variant not found"))
	}
}

func (a *AddressVirtual) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Uri != "" {
		fields["uri"] = json.StringNode("", a.Uri)
	}

	return json.ObjectNode("", fields)
}

func (a *AddressVirtual) FromJSON(node *json.Node) {
	*a = AddressVirtual{}
	fields := node.MustObject()

	if val, ok := fields["uri"]; ok {
		a.Uri = val.MustString()
	}
}

func (a *AddressGeo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Address != "" {
		fields["address"] = json.StringNode("", a.Address)
	}
	if a.Lat != 0 {
		fields["lat"] = json.NumberNode("", float64(a.Lat))
	}
	if a.Lng != 0 {
		fields["lng"] = json.NumberNode("", float64(a.Lng))
	}
	if a.Size != 0 {
		fields["size"] = json.NumberNode("", float64(a.Size))
	}

	return json.ObjectNode("", fields)
}

func (a *AddressGeo) FromJSON(node *json.Node) {
	*a = AddressGeo{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		a.Address = val.MustString()
	}
	if val, ok := fields["lat"]; ok {
		a.Lat = float32(val.MustNumeric())
	}
	if val, ok := fields["lng"]; ok {
		a.Lng = float32(val.MustNumeric())
	}
	if val, ok := fields["size"]; ok {
		a.Size = float32(val.MustNumeric())
	}
}

func (a *AddressCustom) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Address != "" {
		fields["address"] = json.StringNode("", a.Address)
	}
	if a.Timezone != "" {
		fields["timezone"] = json.StringNode("", a.Timezone)
	}

	return json.ObjectNode("", fields)
}

func (a *AddressCustom) FromJSON(node *json.Node) {
	*a = AddressCustom{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		a.Address = val.MustString()
	}
	if val, ok := fields["timezone"]; ok {
		a.Timezone = val.MustString()
	}
}

func (e *EventPrivacy) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	switch val := e.EventPrivacy.(type) {
	case *EventPrivacyPublic:
		fields["public"] = val.ToJSON()
	case *EventPrivacyGuarded:
		fields["guarded"] = val.ToJSON()
	default:
		panic(errors.New("unknown eventPrivacy variant"))
	}

	return json.ObjectNode("", fields)
}

func (e *EventPrivacy) FromJSON(node *json.Node) {
	*e = EventPrivacy{}
	fields := node.MustObject()

	variantFieldNames := []string{"public", "guarded"}
	var selectedVariant *json.Node
	var selectedVariantName string
	for _, variantName := range variantFieldNames {
		if variant, ok := fields[variantName]; ok {
			selectedVariantName = variantName
			selectedVariant = variant
		}
		break
	}
	switch selectedVariantName {
	case "public":
		n := &EventPrivacyPublic{}
		n.FromJSON(selectedVariant)
		e.EventPrivacy = n
	case "guarded":
		n := &EventPrivacyGuarded{}
		n.FromJSON(selectedVariant)
		e.EventPrivacy = n
	default:
		panic(errors.New("eventPrivacy variant not found"))
	}
}

func (e *EventPrivacyPublic) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func (e *EventPrivacyPublic) FromJSON(node *json.Node) {
	*e = EventPrivacyPublic{}
}

func (e *EventPrivacyGuarded) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.ParticipationPubkey != "" {
		fields["participationPubkey"] = json.StringNode("", e.ParticipationPubkey)
	}

	return json.ObjectNode("", fields)
}

func (e *EventPrivacyGuarded) FromJSON(node *json.Node) {
	*e = EventPrivacyGuarded{}
	fields := node.MustObject()

	if val, ok := fields["participationPubkey"]; ok {
		e.ParticipationPubkey = val.MustString()
	}
}

func (e *EventInfo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Title != "" {
		fields["title"] = json.StringNode("", e.Title)
	}
	if e.Description != "" {
		fields["description"] = json.StringNode("", e.Description)
	}
	if e.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", e.ImageUri)
	}
	if len(e.Organizers) != 0 {
		arr := make([]*json.Node, len(e.Organizers))
		for i, val := range e.Organizers {
			arr[i] = json.StringNode("", val)
		}
		fields["organizers"] = json.ArrayNode("", arr)
	}
	if len(e.Gatekeepers) != 0 {
		arr := make([]*json.Node, len(e.Gatekeepers))
		for i, val := range e.Gatekeepers {
			arr[i] = json.StringNode("", val)
		}
		fields["gatekeepers"] = json.ArrayNode("", arr)
	}
	if e.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatInt(e.StartDate, 10))
	}
	if e.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatInt(e.EndDate, 10))
	}
	if e.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(e.Capacity))
	}
	if e.Location != nil {
		fields["location"] = e.Location.ToJSON()
	}
	if e.Participants != 0 {
		fields["participants"] = json.NumberNode("", float64(e.Participants))
	}
	if e.PkgPath != "" {
		fields["pkgPath"] = json.StringNode("", e.PkgPath)
	}
	if e.Privacy != nil {
		fields["privacy"] = e.Privacy.ToJSON()
	}

	return json.ObjectNode("", fields)
}

func (e *EventInfo) FromJSON(node *json.Node) {
	*e = EventInfo{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		e.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		e.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		e.ImageUri = val.MustString()
	}
	if val, ok := fields["organizers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Organizers = arr
	}
	if val, ok := fields["gatekeepers"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Gatekeepers = arr
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		e.EndDate = fv
	}
	if val, ok := fields["capacity"]; ok {
		e.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		fv.FromJSON(val)
		e.Location = fv
	}
	if val, ok := fields["participants"]; ok {
		e.Participants = uint32(val.MustNumeric())
	}
	if val, ok := fields["pkgPath"]; ok {
		e.PkgPath = val.MustString()
	}
	if val, ok := fields["privacy"]; ok {
		fv := &EventPrivacy{}
		fv.FromJSON(val)
		e.Privacy = fv
	}
}

func (b *BatchProfileField) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if b.Type != "" {
		fields["type"] = json.StringNode("", b.Type)
	}
	if b.Key != "" {
		fields["key"] = json.StringNode("", b.Key)
	}

	return json.ObjectNode("", fields)
}

func (b *BatchProfileField) FromJSON(node *json.Node) {
	*b = BatchProfileField{}
	fields := node.MustObject()

	if val, ok := fields["type"]; ok {
		b.Type = val.MustString()
	}
	if val, ok := fields["key"]; ok {
		b.Key = val.MustString()
	}
}

func (b *BatchProfileRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(b.Fields) != 0 {
		arr := make([]*json.Node, len(b.Fields))
		for i, val := range b.Fields {
			arr[i] = val.ToJSON()
		}
		fields["fields"] = json.ArrayNode("", arr)
	}
	if len(b.Addresses) != 0 {
		arr := make([]*json.Node, len(b.Addresses))
		for i, val := range b.Addresses {
			arr[i] = json.StringNode("", val)
		}
		fields["addresses"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func (b *BatchProfileRequest) FromJSON(node *json.Node) {
	*b = BatchProfileRequest{}
	fields := node.MustObject()

	if val, ok := fields["fields"]; ok {
		jarr := val.MustArray()
		arr := make([]*BatchProfileField, len(jarr))
		for i, val := range jarr {
			fv := &BatchProfileField{}
			fv.FromJSON(val)
			arr[i] = fv
		}
		b.Fields = arr
	}
	if val, ok := fields["addresses"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		b.Addresses = arr
	}
}

func (c *CreatePollRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.EventId != "" {
		fields["eventId"] = json.StringNode("", c.EventId)
	}
	if c.Question != "" {
		fields["question"] = json.StringNode("", c.Question)
	}
	if len(c.Options) != 0 {
		arr := make([]*json.Node, len(c.Options))
		for i, val := range c.Options {
			arr[i] = json.StringNode("", val)
		}
		fields["options"] = json.ArrayNode("", arr)
	}
	if c.Duration != 0 {
		fields["duration"] = json.StringNode("", strconv.FormatInt(c.Duration, 10))
	}
	if c.Kind != 0 {
		fields["kind"] = json.StringNode("", c.Kind.ToString())
	}

	return json.ObjectNode("", fields)
}

func (c *CreatePollRequest) FromJSON(node *json.Node) {
	*c = CreatePollRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		c.EventId = val.MustString()
	}
	if val, ok := fields["question"]; ok {
		c.Question = val.MustString()
	}
	if val, ok := fields["options"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		c.Options = arr
	}
	if val, ok := fields["duration"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64)
		if err != nil {
			panic(err)
		}
		c.Duration = fv
	}
	if val, ok := fields["kind"]; ok {
		c.Kind = v1.PollKindFromString(val.MustString())
	}
}

func (c *CreatePollResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.PostId != "" {
		fields["postId"] = json.StringNode("", c.PostId)
	}

	return json.ObjectNode("", fields)
}

func (c *CreatePollResponse) FromJSON(node *json.Node) {
	*c = CreatePollResponse{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		c.PostId = val.MustString()
	}
}

func (v *VotePollRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if v.PollId != "" {
		fields["pollId"] = json.StringNode("", v.PollId)
	}
	if v.Option != "" {
		fields["option"] = json.StringNode("", v.Option)
	}

	return json.ObjectNode("", fields)
}

func (v *VotePollRequest) FromJSON(node *json.Node) {
	*v = VotePollRequest{}
	fields := node.MustObject()

	if val, ok := fields["pollId"]; ok {
		v.PollId = val.MustString()
	}
	if val, ok := fields["option"]; ok {
		v.Option = val.MustString()
	}
}

func (v *VotePollResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func (v *VotePollResponse) FromJSON(node *json.Node) {
	*v = VotePollResponse{}
}

func (c *CreatePostRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.EventId != "" {
		fields["eventId"] = json.StringNode("", c.EventId)
	}
	if c.Content != "" {
		fields["content"] = json.StringNode("", c.Content)
	}
	if c.ParentId != "" {
		fields["parentId"] = json.StringNode("", c.ParentId)
	}
	if len(c.Tags) != 0 {
		arr := make([]*json.Node, len(c.Tags))
		for i, val := range c.Tags {
			arr[i] = json.StringNode("", val)
		}
		fields["tags"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func (c *CreatePostRequest) FromJSON(node *json.Node) {
	*c = CreatePostRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		c.EventId = val.MustString()
	}
	if val, ok := fields["content"]; ok {
		c.Content = val.MustString()
	}
	if val, ok := fields["parentId"]; ok {
		c.ParentId = val.MustString()
	}
	if val, ok := fields["tags"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		c.Tags = arr
	}
}

func (c *CreatePostResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.PostId != "" {
		fields["postId"] = json.StringNode("", c.PostId)
	}

	return json.ObjectNode("", fields)
}

func (c *CreatePostResponse) FromJSON(node *json.Node) {
	*c = CreatePostResponse{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		c.PostId = val.MustString()
	}
}

func (r *ReactPostRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if r.PostId != "" {
		fields["postId"] = json.StringNode("", r.PostId)
	}
	if r.Icon != "" {
		fields["icon"] = json.StringNode("", r.Icon)
	}

	return json.ObjectNode("", fields)
}

func (r *ReactPostRequest) FromJSON(node *json.Node) {
	*r = ReactPostRequest{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		r.PostId = val.MustString()
	}
	if val, ok := fields["icon"]; ok {
		r.Icon = val.MustString()
	}
}

func (r *ReactPostResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func (r *ReactPostResponse) FromJSON(node *json.Node) {
	*r = ReactPostResponse{}
}

func (e *EditPostRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.PostId != "" {
		fields["postId"] = json.StringNode("", e.PostId)
	}
	if e.Content != "" {
		fields["content"] = json.StringNode("", e.Content)
	}
	if len(e.Tags) != 0 {
		arr := make([]*json.Node, len(e.Tags))
		for i, val := range e.Tags {
			arr[i] = json.StringNode("", val)
		}
		fields["tags"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func (e *EditPostRequest) FromJSON(node *json.Node) {
	*e = EditPostRequest{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		e.PostId = val.MustString()
	}
	if val, ok := fields["content"]; ok {
		e.Content = val.MustString()
	}
	if val, ok := fields["tags"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		e.Tags = arr
	}
}

func (e *EditPostResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.PostId != "" {
		fields["postId"] = json.StringNode("", e.PostId)
	}

	return json.ObjectNode("", fields)
}

func (e *EditPostResponse) FromJSON(node *json.Node) {
	*e = EditPostResponse{}
	fields := node.MustObject()

	if val, ok := fields["postId"]; ok {
		e.PostId = val.MustString()
	}
}

func (g *GetEventTicketsRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.EventId != "" {
		fields["eventId"] = json.StringNode("", g.EventId)
	}

	return json.ObjectNode("", fields)
}

func (g *GetEventTicketsRequest) FromJSON(node *json.Node) {
	*g = GetEventTicketsRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		g.EventId = val.MustString()
	}
}

func (g *GetEventTicketsResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(g.TicketsInfo) != 0 {
		arr := make([]*json.Node, len(g.TicketsInfo))
		for i, val := range g.TicketsInfo {
			arr[i] = val.ToJSON()
		}
		fields["ticketsInfo"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func (g *GetEventTicketsResponse) FromJSON(node *json.Node) {
	*g = GetEventTicketsResponse{}
	fields := node.MustObject()

	if val, ok := fields["ticketsInfo"]; ok {
		jarr := val.MustArray()
		arr := make([]*TicketInfo, len(jarr))
		for i, val := range jarr {
			fv := &TicketInfo{}
			fv.FromJSON(val)
			arr[i] = fv
		}
		g.TicketsInfo = arr
	}
}

func (t *TicketInfo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if t.TicketSecret != "" {
		fields["ticketSecret"] = json.StringNode("", t.TicketSecret)
	}
	if t.UserEmail != "" {
		fields["userEmail"] = json.StringNode("", t.UserEmail)
	}

	return json.ObjectNode("", fields)
}

func (t *TicketInfo) FromJSON(node *json.Node) {
	*t = TicketInfo{}
	fields := node.MustObject()

	if val, ok := fields["ticketSecret"]; ok {
		t.TicketSecret = val.MustString()
	}
	if val, ok := fields["userEmail"]; ok {
		t.UserEmail = val.MustString()
	}
}

func (c *CheckinRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.TicketPubkey != "" {
		fields["ticketPubkey"] = json.StringNode("", c.TicketPubkey)
	}
	if c.Signature != "" {
		fields["signature"] = json.StringNode("", c.Signature)
	}

	return json.ObjectNode("", fields)
}

func (c *CheckinRequest) FromJSON(node *json.Node) {
	*c = CheckinRequest{}
	fields := node.MustObject()

	if val, ok := fields["ticketPubkey"]; ok {
		c.TicketPubkey = val.MustString()
	}
	if val, ok := fields["signature"]; ok {
		c.Signature = val.MustString()
	}
}

func (c *CheckinResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func (c *CheckinResponse) FromJSON(node *json.Node) {
	*c = CheckinResponse{}
}
