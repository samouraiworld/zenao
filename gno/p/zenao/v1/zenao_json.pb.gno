// Code generated by protoc-gen-gno. DO NOT EDIT.

package zenaov1

import (
	"errors"
	"strconv"
	"gno.land/p/demo/json"
)

func (e *EditUserRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.DisplayName != "" {
		fields["displayName"] = json.StringNode("", e.DisplayName)
	}
	if e.Bio != "" {
		fields["bio"] = json.StringNode("", e.Bio)
	}
	if e.AvatarUri != "" {
		fields["avatarUri"] = json.StringNode("", e.AvatarUri)
	}

	return json.ObjectNode("", fields)
}

func (e *EditUserRequest) FromJSON(node *json.Node) {
	*e = EditUserRequest{}
	fields := node.MustObject()

	if val, ok := fields["displayName"]; ok {
		e.DisplayName = val.MustString()
	}
	if val, ok := fields["bio"]; ok {
		e.Bio = val.MustString()
	}
	if val, ok := fields["avatarUri"]; ok {
		e.AvatarUri = val.MustString()
	}
}

func (e *EditUserResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Id != "" {
		fields["id"] = json.StringNode("", e.Id)
	}

	return json.ObjectNode("", fields)
}

func (e *EditUserResponse) FromJSON(node *json.Node) {
	*e = EditUserResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		e.Id = val.MustString()
	}
}

func (g *GetUserAddressRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	return json.ObjectNode("", fields)
}

func (g *GetUserAddressRequest) FromJSON(node *json.Node) {
	*g = GetUserAddressRequest{}
}

func (g *GetUserAddressResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if g.Address != "" {
		fields["address"] = json.StringNode("", g.Address)
	}

	return json.ObjectNode("", fields)
}

func (g *GetUserAddressResponse) FromJSON(node *json.Node) {
	*g = GetUserAddressResponse{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		g.Address = val.MustString()
	}
}

func (c *CreateEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.Title != "" {
		fields["title"] = json.StringNode("", c.Title)
	}
	if c.Description != "" {
		fields["description"] = json.StringNode("", c.Description)
	}
	if c.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", c.ImageUri)
	}
	if c.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatUint(c.StartDate, 10))
	}
	if c.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatUint(c.EndDate, 10))
	}
	if c.TicketPrice != 0 {
		fields["ticketPrice"] = json.NumberNode("", float64(c.TicketPrice))
	}
	if c.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(c.Capacity))
	}
	if c.Location != nil {
		fields["location"] = c.Location.ToJSON()
	}

	return json.ObjectNode("", fields)
}

func (c *CreateEventRequest) FromJSON(node *json.Node) {
	*c = CreateEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		c.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		c.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		c.ImageUri = val.MustString()
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64);
		if err != nil {
			panic(err)
		}
		c.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64);
		if err != nil {
			panic(err)
		}
		c.EndDate = fv
	}
	if val, ok := fields["ticketPrice"]; ok {
		c.TicketPrice = val.MustNumeric()
	}
	if val, ok := fields["capacity"]; ok {
		c.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		fv.FromJSON(val)
		c.Location = fv
	}
}

func (c *CreateEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if c.Id != "" {
		fields["id"] = json.StringNode("", c.Id)
	}

	return json.ObjectNode("", fields)
}

func (c *CreateEventResponse) FromJSON(node *json.Node) {
	*c = CreateEventResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		c.Id = val.MustString()
	}
}

func (e *EditEventRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.EventId != "" {
		fields["eventId"] = json.StringNode("", e.EventId)
	}
	if e.Title != "" {
		fields["title"] = json.StringNode("", e.Title)
	}
	if e.Description != "" {
		fields["description"] = json.StringNode("", e.Description)
	}
	if e.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", e.ImageUri)
	}
	if e.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatUint(e.StartDate, 10))
	}
	if e.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatUint(e.EndDate, 10))
	}
	if e.TicketPrice != 0 {
		fields["ticketPrice"] = json.NumberNode("", float64(e.TicketPrice))
	}
	if e.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(e.Capacity))
	}
	if e.Location != nil {
		fields["location"] = e.Location.ToJSON()
	}

	return json.ObjectNode("", fields)
}

func (e *EditEventRequest) FromJSON(node *json.Node) {
	*e = EditEventRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		e.EventId = val.MustString()
	}
	if val, ok := fields["title"]; ok {
		e.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		e.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		e.ImageUri = val.MustString()
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64);
		if err != nil {
			panic(err)
		}
		e.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseUint(val.MustString(), 10, 64);
		if err != nil {
			panic(err)
		}
		e.EndDate = fv
	}
	if val, ok := fields["ticketPrice"]; ok {
		e.TicketPrice = val.MustNumeric()
	}
	if val, ok := fields["capacity"]; ok {
		e.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		fv.FromJSON(val)
		e.Location = fv
	}
}

func (e *EditEventResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Id != "" {
		fields["id"] = json.StringNode("", e.Id)
	}

	return json.ObjectNode("", fields)
}

func (e *EditEventResponse) FromJSON(node *json.Node) {
	*e = EditEventResponse{}
	fields := node.MustObject()

	if val, ok := fields["id"]; ok {
		e.Id = val.MustString()
	}
}

func (p *ParticipateRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.EventId != "" {
		fields["eventId"] = json.StringNode("", p.EventId)
	}
	if p.Email != "" {
		fields["email"] = json.StringNode("", p.Email)
	}

	return json.ObjectNode("", fields)
}

func (p *ParticipateRequest) FromJSON(node *json.Node) {
	*p = ParticipateRequest{}
	fields := node.MustObject()

	if val, ok := fields["eventId"]; ok {
		p.EventId = val.MustString()
	}
	if val, ok := fields["email"]; ok {
		p.Email = val.MustString()
	}
}

func (p *ParticipateResponse) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if p.TicketSecret != "" {
		fields["ticketSecret"] = json.StringNode("", p.TicketSecret)
	}

	return json.ObjectNode("", fields)
}

func (p *ParticipateResponse) FromJSON(node *json.Node) {
	*p = ParticipateResponse{}
	fields := node.MustObject()

	if val, ok := fields["ticketSecret"]; ok {
		p.TicketSecret = val.MustString()
	}
}

func (e *EventLocation) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.VenueName != "" {
		fields["venueName"] = json.StringNode("", e.VenueName)
	}
	if e.Instructions != "" {
		fields["instructions"] = json.StringNode("", e.Instructions)
	}

	address := map[string]*json.Node{}
	switch val := e.Address.(type) {
	case *AddressGeo:
		address["case"] = json.StringNode("", "geo")
		address["value"] = val.ToJSON()
	case *AddressVirtual:
		address["case"] = json.StringNode("", "virtual")
		address["value"] = val.ToJSON()
	case *AddressCustom:
		address["case"] = json.StringNode("", "custom")
		address["value"] = val.ToJSON()
	default:
		panic(errors.New("unknown address variant"))
	}
	fields["address"] = json.ObjectNode("", address)

	return json.ObjectNode("", fields)
}

func (e *EventLocation) FromJSON(node *json.Node) {
	*e = EventLocation{}
	fields := node.MustObject()

	if val, ok := fields["venueName"]; ok {
		e.VenueName = val.MustString()
	}
	if val, ok := fields["instructions"]; ok {
		e.Instructions = val.MustString()
	}

	if union, ok := fields["address"]; ok {
		obj := union.MustObject()
		kind := obj["case"].MustString()
		val := obj["value"]
		switch kind {
		case "geo":
			n := &AddressGeo{}
			n.FromJSON(val)
			e.Address = n
		case "virtual":
			n := &AddressVirtual{}
			n.FromJSON(val)
			e.Address = n
		case "custom":
			n := &AddressCustom{}
			n.FromJSON(val)
			e.Address = n
		default:
			panic(errors.New("unknown address variant"))
		}
	}
}

func (a *AddressVirtual) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Uri != "" {
		fields["uri"] = json.StringNode("", a.Uri)
	}

	return json.ObjectNode("", fields)
}

func (a *AddressVirtual) FromJSON(node *json.Node) {
	*a = AddressVirtual{}
	fields := node.MustObject()

	if val, ok := fields["uri"]; ok {
		a.Uri = val.MustString()
	}
}

func (a *AddressGeo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Address != "" {
		fields["address"] = json.StringNode("", a.Address)
	}
	if a.Lat != 0 {
		fields["lat"] = json.NumberNode("", float64(a.Lat))
	}
	if a.Lng != 0 {
		fields["lng"] = json.NumberNode("", float64(a.Lng))
	}
	if a.Size != 0 {
		fields["size"] = json.NumberNode("", float64(a.Size))
	}

	return json.ObjectNode("", fields)
}

func (a *AddressGeo) FromJSON(node *json.Node) {
	*a = AddressGeo{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		a.Address = val.MustString()
	}
	if val, ok := fields["lat"]; ok {
		a.Lat = float32(val.MustNumeric())
	}
	if val, ok := fields["lng"]; ok {
		a.Lng = float32(val.MustNumeric())
	}
	if val, ok := fields["size"]; ok {
		a.Size = float32(val.MustNumeric())
	}
}

func (a *AddressCustom) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if a.Address != "" {
		fields["address"] = json.StringNode("", a.Address)
	}
	if a.Timezone != "" {
		fields["timezone"] = json.StringNode("", a.Timezone)
	}

	return json.ObjectNode("", fields)
}

func (a *AddressCustom) FromJSON(node *json.Node) {
	*a = AddressCustom{}
	fields := node.MustObject()

	if val, ok := fields["address"]; ok {
		a.Address = val.MustString()
	}
	if val, ok := fields["timezone"]; ok {
		a.Timezone = val.MustString()
	}
}

func (e *EventInfo) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if e.Title != "" {
		fields["title"] = json.StringNode("", e.Title)
	}
	if e.Description != "" {
		fields["description"] = json.StringNode("", e.Description)
	}
	if e.ImageUri != "" {
		fields["imageUri"] = json.StringNode("", e.ImageUri)
	}
	if e.Creator != "" {
		fields["creator"] = json.StringNode("", e.Creator)
	}
	if e.StartDate != 0 {
		fields["startDate"] = json.StringNode("", strconv.FormatInt(e.StartDate, 10))
	}
	if e.EndDate != 0 {
		fields["endDate"] = json.StringNode("", strconv.FormatInt(e.EndDate, 10))
	}
	if e.Capacity != 0 {
		fields["capacity"] = json.NumberNode("", float64(e.Capacity))
	}
	if e.Location != nil {
		fields["location"] = e.Location.ToJSON()
	}
	if e.Participants != 0 {
		fields["participants"] = json.NumberNode("", float64(e.Participants))
	}
	if e.PkgPath != "" {
		fields["pkgPath"] = json.StringNode("", e.PkgPath)
	}

	return json.ObjectNode("", fields)
}

func (e *EventInfo) FromJSON(node *json.Node) {
	*e = EventInfo{}
	fields := node.MustObject()

	if val, ok := fields["title"]; ok {
		e.Title = val.MustString()
	}
	if val, ok := fields["description"]; ok {
		e.Description = val.MustString()
	}
	if val, ok := fields["imageUri"]; ok {
		e.ImageUri = val.MustString()
	}
	if val, ok := fields["creator"]; ok {
		e.Creator = val.MustString()
	}
	if val, ok := fields["startDate"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64);
		if err != nil {
			panic(err)
		}
		e.StartDate = fv
	}
	if val, ok := fields["endDate"]; ok {
		fv, err := strconv.ParseInt(val.MustString(), 10, 64);
		if err != nil {
			panic(err)
		}
		e.EndDate = fv
	}
	if val, ok := fields["capacity"]; ok {
		e.Capacity = uint32(val.MustNumeric())
	}
	if val, ok := fields["location"]; ok {
		fv := &EventLocation{}
		fv.FromJSON(val)
		e.Location = fv
	}
	if val, ok := fields["participants"]; ok {
		e.Participants = uint32(val.MustNumeric())
	}
	if val, ok := fields["pkgPath"]; ok {
		e.PkgPath = val.MustString()
	}
}

func (b *BatchProfileField) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if b.Type != "" {
		fields["type"] = json.StringNode("", b.Type)
	}
	if b.Key != "" {
		fields["key"] = json.StringNode("", b.Key)
	}

	return json.ObjectNode("", fields)
}

func (b *BatchProfileField) FromJSON(node *json.Node) {
	*b = BatchProfileField{}
	fields := node.MustObject()

	if val, ok := fields["type"]; ok {
		b.Type = val.MustString()
	}
	if val, ok := fields["key"]; ok {
		b.Key = val.MustString()
	}
}

func (b *BatchProfileRequest) ToJSON() *json.Node {
	fields := map[string]*json.Node{}

	if len(b.Fields) != 0 {
		arr := make([]*json.Node, len(b.Fields))
		for i, val := range b.Fields {
			arr[i] = val.ToJSON()
		}
		fields["fields"] = json.ArrayNode("", arr)
	}
	if len(b.Addresses) != 0 {
		arr := make([]*json.Node, len(b.Addresses))
		for i, val := range b.Addresses {
			arr[i] = json.StringNode("", val)
		}
		fields["addresses"] = json.ArrayNode("", arr)
	}

	return json.ObjectNode("", fields)
}

func (b *BatchProfileRequest) FromJSON(node *json.Node) {
	*b = BatchProfileRequest{}
	fields := node.MustObject()

	if val, ok := fields["fields"]; ok {
		jarr := val.MustArray()
		arr := make([]*BatchProfileField, len(jarr))
		for i, val := range jarr {
			fv := &BatchProfileField{}
			fv.FromJSON(val)
			arr[i] = fv
		}
		b.Fields = arr
	}
	if val, ok := fields["addresses"]; ok {
		jarr := val.MustArray()
		arr := make([]string, len(jarr))
		for i, val := range jarr {
			arr[i] = val.MustString()
		}
		b.Addresses = arr
	}
}
